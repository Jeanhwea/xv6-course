#+TITLE: 进程初探
#+AUTHOR: Jinghui Hu
#+EMAIL: hujinghui@buaa.edu.cn
#+DATE: <2023-11-13 Mon>
#+STARTUP: overview num indent
#+OPTIONS: ^:nil


* 究竟什么是进程
进程是一个抽象概念，它是操作系统对计算资源的抽象

1. 编译时程序可以假设它独占一台机器，编译器在编译时就可以产生固定的地址
   #+BEGIN_SRC sh
     cc hello.c
   #+END_SRC
2. 操作系统需要管理所有用户提交的程序，所以抽象出进程的概念
   #+BEGIN_SRC sh
     top
   #+END_SRC
3. 编译好的程序 (a.out) 执行代码相当于与把控制权交给操作系统
   - 操作系统会给 a.out 分配虚拟地址空间，通过分页机制使得进程彼此隔离
     - a.out 静态的 / 文件
     - process 动态的 / 运行的 CPU
   - 同一个 a.out 在不同时刻运行产生的实体(也就是进程)，拥有自己的资源
     - CPU 时间片
     - 地址空间
     - 相关属性 (pid), 在 xv6 中的 ~struct proc~ 结构体
     - 打开的文件
     - 等等
   - 进程在内核态和用户态上下文切换时需要保存一些状态
     - ~p->kstack~ 内核栈
     - ~p->state~ 进程状态
       #+BEGIN_SRC c
         enum procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };
       #+END_SRC

[[file:../../study/os/xv6-public/proc.h::struct proc {]]

* 操作系统的第一个进程
1. userinit 创建第一个进程
   - [[file:../../study/os/xv6-public/main.c::userinit(); // first user process]]
   - 加载 initcode.S 并启动
2. allocproc() 分配进程数据结构体 proc
   - ptable 记录所有进程表
   - 查找到 proc 结构体, 设置 p->state = EMBRYO
   - 分配内核栈 p->kstack, 页面大小 KSTACKSIZE
   #+BEGIN_EXAMPLE
                  |-------------| TOP STACK (total KSTACKSIZE(4K))
                  |    esp      |
                  |    ...      |
                  |    eip      |
                  |    ...      |
                  |    edi      |
                  |-------------| <- p->tf
                  |  trapret    |
                  |-------------| <- fork() return address
                  |    eip      |
                  |             |
                  |    ...      |
                  |    edi      |
                  |-------------| <- p->context
                  |             |
                  |             |
                  |   (empty)   |
                  |             |
                  |             |
     p->kstack -> |-------------|
   #+END_EXAMPLE
3. setupkvm 初始化页表
4. inituvm 初始化, 加载用户代码
   - 地址范围 0 ~ PGSIZE
   - memmove 复制数据
