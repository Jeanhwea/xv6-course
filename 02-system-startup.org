#+TITLE: 走进操作系统
#+AUTHOR: Jinghui Hu
#+EMAIL: hujinghui@buaa.edu.cn
#+DATE: <2023-10-30 Mon>
#+STARTUP: overview num indent


* 系统概览
** 用户态/内核态
#+BEGIN_SRC text
  ------------+==================================================
              |
              |    vi       cat          echo
  User Mode   |     |   sh   |      ls    |
              |     |   |    |      |     |
              |     +---------+-----+-----+
              |               |
              |               v
  ------------|=========== SYSCALL ==============================
              |             |    ^
              |             |    +------------+
              |             v                 |
  Kernel Mode |       [sys_fork/sys_exec] -> [exec/io_wait]
              |
              |               [scheduler]
  ------------+==================================================
#+END_SRC

1. RING 3 被叫做用户态，在应用程序中运行
2. RING 0 被叫做内核态，完全在操作系统内核中运行
3. 内核态有一些特权的命令
   - cli 关中断 [[file:lab/08-kernel-user-mode/kernel.S]]
   - sti 开中断
   - 但是用户态程序不行 [[file:lab/08-kernel-user-mode/user.S]]

** 系统调用
xv6 实现了如下的系统调用, 系统调用是操作系统提供给用户进程编写代码的 API

| NO. | SYSCALL                   | Description                                |
|-----+---------------------------+--------------------------------------------|
|   1 | fork()                    | Create a process                           |
|   2 | exit()                    | Terminate the current process              |
|   3 | wait()                    | Wait for a child process to exit           |
|   4 | kill(pid)                 | Terminate process pid                      |
|   5 | getpid()                  | Return the current process’s pid           |
|   6 | sleep(n)                  | Sleep for n clock ticks                    |
|   7 | exec(filename, *argv)     | Load a file and execute it                 |
|   8 | sbrk(n)                   | Grow process’s memory by n bytes           |
|   9 | open(filename, flags)     | Open a file; the flags indicate read/write |
|  10 | read(fd, buf, n)          | Read n bytes from an open file into buf    |
|  11 | write(fd, buf, n)         | Write n bytes to an open file              |
|  12 | close(fd)                 | Release open file fd                       |
|  13 | dup(fd)                   | Duplicate fd                               |
|  14 | pipe(p)                   | Create a pipe and return fd’s in p         |
|  15 | chdir(dirname)            | Change the current directory               |
|  16 | mkdir(dirname)            | Create a new directory                     |
|  17 | mknod(name, major, minor) | Create a device file                       |
|  18 | fstat(fd)                 | Return info about an open file             |
|  19 | link(f1, f2)              | Create another name (f2) for the file f1   |
|  20 | unlink(filename)          | Remove a file                              |


[[file:lab/09-linux-syscall/forkme.c]]

** 地址空间
1. 操作系统的每个进程都有自己的地址空间
   1) 这个空间只用进程内部是可见的，也称虚拟地址空间，不同进程的地址空间是隔离的
      - 如果不隔离会出现什么情况?
   2) xv6 虚拟地址空间如下
     #+BEGIN_EXAMPLE
       0xFFFFFFFF -> |-------------|  -
                     |             |  ^
                     |             |  |
                     |             |  |
                     | Free Memory |
                     |             |
                     |             | Kernel Space
                     |-------------|
                     | Text & Data |
                     |             |  |
       0x80100000 -> |-------------|  |
                     |     BIOS    |  v
       0x80000000 -> |-------------|  -
       (KERNBASE)    |     Heap    |  ^
                     |      |      |  |
                     |      v      |  |
                     |     ...     |  |
                     |             |
                     |             |
                     |             |
                     |             |
                     |             | User Space
                     |-------------|
                     |     ...     |
                     |             |
                     |      ^      |
                     |      |      |  |
                     |  User stack |  |
                     |-------------|  |
                     |             |  |
                     |    User     |  |
                     | Text & Data |  v
       0x0        -> |-------------|  -
     #+END_EXAMPLE
   3) xv6 虚拟地址空间 -> 物理地址空间
     #+BEGIN_EXAMPLE
       0xFFFFFFFF -> |-------------|
                     |             |
                     |             |
                     |             |
                     | Free Memory |
                     |             |
                     |             |
                     |-------------|
                     | Text & Data |
                     |             |
       0x80100000 -> |-------------| -------+
                     |     BIOS    |        |
       0x80000000 -> |-------------| ----+  |
       (KERNBASE)    |     Heap    |     |  |
                     |      |      |     |  |
                     |      v      |     |  |
                     |     ...     |     |  |
                     |             |     |  |
                     |             |     |  |
                     |             |     |  |
                     |             |     |  |
                     |             |     |  |       |-------------| <- Top Physical memory
                     |-------------|     |  |       |             |
                     |     ...     |     |  |       |             |
                     |             |     |  |       |             |
                     |      ^      |     |  |       |             |
                     |      |      |     |  |       |-------------|  <- 4M
                     |  User stack |     |  |       |    Kernel   |
                     |-------------|     |  |       | Text & Data |
                     |             |     |  |       |             |
                     |    User     |     |  +-----> |-------------|
                     | Text & Data |     |          |     BIOS    |
       0x0        -> |-------------|     +--------> |-------------|  <- 0x0

       VIRTUAL                                                       PHYSICAL
     #+END_EXAMPLE

2. xv6 的地址管理: 保护分页/页表
   1) xv6 为每个进程维护一个页表
   2) 用以描述每个进程的用户地址空间，外加一个单独描述内核地址空间的页表
   3) 虚拟地址访问物理内存和各种硬件资源
      - 虚拟地址 va (virtual address)
      - 物理地址 pa (physical address)
      - va -> pa 通过分页机制实现
   4) 为什么需要搞虚拟地址或物理地址?

** 进程管理
1. 并发 (Concurrency) 实现
   - 分时运行
   - 时间中断抢夺运行权利
2. 并行 (Parallelism) 实现
   - 程序真实同时运行

#+BEGIN_EXAMPLE
#+END_EXAMPLE

* x86 实模式和保护模式
** GDT
1. GDT 主要保护以下信息, 总共 64 位, [[https://files.osdev.org/mirrors/geezer/os/pm.htm][link]]
   - base  = low(16) + middle(8) + high(8)
   - limit = low(16) + high(4)
   - flags = (12)
2. GDT 的第一项必须全是 ~0x00~
3. GDT 加载通过 ~lgdt~ 指令

下面是一个初始化的 gdt 内存定义，这里先将代码段和数据段合并在一起
#+BEGIN_SRC nasm
  gdt_start: ; don't remove the labels, they're needed to compute sizes and jumps
      ; the GDT starts with a null 8-byte
      dd 0x0 ; 4 byte
      dd 0x0 ; 4 byte

  ; GDT for code segment. base = 0x00000000, length = 0xfffff
  gdt_code:
      dw 0xffff    ; segment length, bits 0-15                    | limit_low(16)
      dw 0x0       ; segment base, bits 0-15                      | base_low(16)
      db 0x0       ; segment base, bits 16-23                     | base_middle(8)
      db 10011010b ; flags (8 bits)                               | flags1(8)
      db 11001111b ; flags (4 bits) + segment length, bits 16-19  | limit_high(4), flags2(4)
      db 0x0       ; segment base, bits 24-31                     | base_high(8)

  gdt_data:
      dw 0xffff
      dw 0x0
      db 0x0
      db 10010010b
      db 11001111b
      db 0x0

  gdt_end:

  ; GDT descriptor, via lgdt [gdt_descriptor]
  gdt_descriptor:
      dw gdt_end - gdt_start - 1 ; size (16 bit), always one less of its true size
      dd gdt_start               ; address (32 bit)

  ; define some constants for later use
  CODE_SEG equ gdt_code - gdt_start
  DATA_SEG equ gdt_data - gdt_start
#+END_SRC

** 实模式到保护模式切换
1. 关闭中断
2. 加载 gdt
3. 设置控制寄存器 ~cr0~
4. 通过远程调整来 flush 流水线
5. 更新所以的段寄存器
6. 更新系统栈
7. 跳转到 32 位指令出执行

#+BEGIN_SRC nasm
  ;;; real mode
  [bits 16]
  switch_to_pm:
      cli                         ; 1. disable interrupts
      lgdt [gdt_descriptor]       ; 2. load the GDT descriptor
      mov eax, cr0
      or eax, 0x1                 ; 3. set 32-bit mode bit in cr0
      mov cr0, eax
      jmp CODE_SEG:init_pm        ; 4. far jump by using a different segment

  ;;; protected mode is enabled
  [bits 32]
  init_pm:
      mov ax, DATA_SEG            ; 5. update the segment registers
      mov ds, ax
      mov ss, ax
      mov es, ax
      mov fs, ax
      mov gs, ax

      mov ebp, 0x90000            ; 6. update the stack right at the top of the free space
      mov esp, ebp

      call BEGIN_PM               ; 7. Call a well-known label with useful code
#+END_SRC
