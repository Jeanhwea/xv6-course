#+TITLE: x86 体系结构及系统启动
#+AUTHOR: Jinghui Hu
#+EMAIL: hujinghui@buaa.edu.cn
#+DATE: <2023-10-23 Mon 13:26:59>
#+STARTUP: overview num indent

* x86 体系结构
** 寄存器及编译流程
| 分类         | 英文全称            | 16 位 | 32 位 | 64 位 |
|--------------+---------------------+-------+-------+-------|
| 通用寄存器   | Accumulator         | ax    | eax   | rax   |
| 通用寄存器   | Base                | bx    | ebx   | rbx   |
| 通用寄存器   | Counter             | cx    | ecx   | rcx   |
| 通用寄存器   | Data                | dx    | edx   | rdx   |
| 指针寄存器   | Stack Pointer       | sp    | esp   | rsp   |
| 指针寄存器   | Base Pointer        | bp    | ebp   | rbp   |
| 变地址寄存器 | Source Index        | si    | esi   | rsi   |
| 变地址寄存器 | Destination Index   | di    | edi   | rdi   |
| 控制寄存器   | Instruction Pointer | ip    | eip   | rip   |
| 控制寄存器   | Flag                | flag  | flag  | flag  |
| 段寄存器     | Code Segment        | cs    | cs    | cs    |
| 段寄存器     | Data Segment        | ds    | ds    | ds    |
| 段寄存器     | Stack Segment       | ss    | ss    | ss    |
| 段寄存器     | Extra Segment       | es    | es    | es    |

[[file:../lab/01-register/main.S]]

操作示例
#+BEGIN_EXAMPLE
  info reg
  info reg eax
  p $esp

  layout asm
  layout reg
#+END_EXAMPLE

ubuntu 分清 32 位和 64 位, 如果是 64 为系统需要安装 32 为支持库
#+BEGIN_SRC sh
  apt install gcc-multilib
#+END_SRC

** 栈操作 push/pop
1. esp 指向栈的顶端
2. ebp 指向栈的基地址
3. push 操作时, esp = esp - 4, ebp 不变 (32b)
4. pop 操作时,  esp = esp + 4, ebp 不变

#+BEGIN_EXAMPLE
  origin:
     8 | 0x1 |
     7 | 0x2 | <- ebp  <-esp
     6 | 0x2 |
     5 | 0x2 |
     4 | 0x2 |
     3 | 0x2 |

  push: 操作后
     8 | 0x1 |
     7 | 0x2 | <- ebp
     6 | 0x0 |
     5 | 0x1 |
     4 | 0x0 |
     3 | 0x0 |        <-esp

  pop: 操作后
     8 | 0x1 |
     7 | 0x2 | <- ebp  <-esp
     6 | 0x0 |
     5 | 0x1 |
     4 | 0x0 |
     8 | 0x0 |
#+END_EXAMPLE

[[file:../lab/02-stack/main.S]]

.gdbinit 定义 hook, 设置 watch point
#+BEGIN_EXAMPLE
  define hook-stepi
    if $ebp > 0
      # printf "ebp=%p, esp=%p\n", $ebp, $esp
      x/4x $ebp-16
      x/i $eip
    end
  end

  starti
  watch $ebp
  watch $esp
#+END_EXAMPLE

** 分支跳转 jmp
通常汇编的跳转通过 ~cmp~, ~je~, ~jmp~ 等指令配合实现，例如
#+BEGIN_SRC asm
  jmp label
#+END_SRC

[[file:../lab/03-control-flow/jump.S]]

** 函数调用 call/ret
函数调用也属于简单的跳转指令, 例如
- call 调用函数
- ret 函数返回

[[file:../lab/03-control-flow/fcall.S]]

使用 gcc 编译的真实函数调用
#+BEGIN_SRC sh
  gcc -m32 -O0 adder.c -o adder.out
  objdump -d adder.out > adder.asm
#+END_SRC

[[file:../lab/03-control-flow/adder.c]]

#+BEGIN_SRC asm
  0000118d <add>:
      118d:	55                      push   %ebp
      118e:	89 e5                   mov    %esp,%ebp
      1190:	83 ec 10                sub    $0x10,%esp
      1193:	e8 49 00 00 00          call   11e1 <__x86.get_pc_thunk.ax>
      1198:	05 44 2e 00 00          add    $0x2e44,%eax
      119d:	8b 55 08                mov    0x8(%ebp),%edx
      11a0:	8b 45 0c                mov    0xc(%ebp),%eax
      11a3:	01 d0                   add    %edx,%eax
      11a5:	89 45 fc                mov    %eax,-0x4(%ebp)
      11a8:	8b 45 fc                mov    -0x4(%ebp),%eax
      11ab:	c9                      leave
      11ac:	c3                      ret

  000011ad <main>:
      11ad:	55                      push   %ebp
      11ae:	89 e5                   mov    %esp,%ebp
      11b0:	83 ec 10                sub    $0x10,%esp
      11b3:	e8 29 00 00 00          call   11e1 <__x86.get_pc_thunk.ax>
      11b8:	05 24 2e 00 00          add    $0x2e24,%eax
      11bd:	c7 45 f4 03 00 00 00    movl   $0x3,-0xc(%ebp)
      11c4:	c7 45 f8 04 00 00 00    movl   $0x4,-0x8(%ebp)
      11cb:	ff 75 f8                push   -0x8(%ebp)
      11ce:	ff 75 f4                push   -0xc(%ebp)
      11d1:	e8 b7 ff ff ff          call   118d <add>
      11d6:	83 c4 08                add    $0x8,%esp
      11d9:	89 45 fc                mov    %eax,-0x4(%ebp)
      11dc:	8b 45 fc                mov    -0x4(%ebp),%eax
      11df:	c9                      leave
      11e0:	c3                      ret
#+END_SRC

* QEMU 模拟器
* BIOS 启动
** 分段
8086 寄存器是 16 位的, 真实地址 = 段地址 << 4 + address
#+BEGIN_SRC asm
  ;;; 设置 ds 段寄存器
  mov bx, 0x7c0
  mov ds, bx
  ;;; 默认使用 ds 段寄存器作为基地址
  mov al, [msg]
  int 0x10

  ;;; 使用 es 段寄存器进行寻址
  mov bx, 0x7c0
  mov es, bx
  mov al, [es:the_secret]
  int 0x10
#+END_SRC

** GDT
1. GDT 主要保护以下信息, 总共 64 位, [[https://files.osdev.org/mirrors/geezer/os/pm.htm][link]]
   - base  = low(16) + middle(8) + high(8)
   - limit = low(16) + high(4)
   - flags = (12)
2. GDT 的第一项必须全是 ~0x00~
3. GDT 加载通过 ~lgdt~ 指令

下面是一个初始化的 gdt 内存定义，这里先将代码段和数据段合并在一起
#+BEGIN_SRC asm
  gdt_start: ; don't remove the labels, they're needed to compute sizes and jumps
      ; the GDT starts with a null 8-byte
      dd 0x0 ; 4 byte
      dd 0x0 ; 4 byte

  ; GDT for code segment. base = 0x00000000, length = 0xfffff
  gdt_code:
      dw 0xffff    ; segment length, bits 0-15                    | limit_low(16)
      dw 0x0       ; segment base, bits 0-15                      | base_low(16)
      db 0x0       ; segment base, bits 16-23                     | base_middle(8)
      db 10011010b ; flags (8 bits)                               | flags1(8)
      db 11001111b ; flags (4 bits) + segment length, bits 16-19  | limit_high(4), flags2(4)
      db 0x0       ; segment base, bits 24-31                     | base_high(8)

  gdt_data:
      dw 0xffff
      dw 0x0
      db 0x0
      db 10010010b
      db 11001111b
      db 0x0

  gdt_end:

  ; GDT descriptor, via lgdt [gdt_descriptor]
  gdt_descriptor:
      dw gdt_end - gdt_start - 1 ; size (16 bit), always one less of its true size
      dd gdt_start               ; address (32 bit)

  ; define some constants for later use
  CODE_SEG equ gdt_code - gdt_start
  DATA_SEG equ gdt_data - gdt_start
#+END_SRC

** 实模式到保护模式切换
1. 关闭中断
2. 加载 gdt
3. 设置控制寄存器 ~cr0~
4. 通过远程调整来 flush 流水线
5. 更新所以的段寄存器
6. 更新系统栈
7. 跳转到 32 位指令出执行

#+BEGIN_SRC asm
  ;;; real mode
  [bits 16]
  switch_to_pm:
      cli                         ; 1. disable interrupts
      lgdt [gdt_descriptor]       ; 2. load the GDT descriptor
      mov eax, cr0
      or eax, 0x1                 ; 3. set 32-bit mode bit in cr0
      mov cr0, eax
      jmp CODE_SEG:init_pm        ; 4. far jump by using a different segment

  ;;; protected mode is enabled
  [bits 32]
  init_pm:
      mov ax, DATA_SEG            ; 5. update the segment registers
      mov ds, ax
      mov ss, ax
      mov es, ax
      mov fs, ax
      mov gs, ax

      mov ebp, 0x90000            ; 6. update the stack right at the top of the free space
      mov esp, ebp

      call BEGIN_PM               ; 7. Call a well-known label with useful code
#+END_SRC
