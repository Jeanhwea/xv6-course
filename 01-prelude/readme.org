#+TITLE: x86 体系结构及系统启动
#+AUTHOR: Jinghui Hu
#+EMAIL: hujinghui@buaa.edu.cn
#+DATE: <2023-10-23 Mon 13:26:59>
#+STARTUP: overview num indent

* x86 体系结构
** 寄存器及编译流程
| 分类         | 英文全称            | 16 位 | 32 位 | 64 位 |
|--------------+---------------------+-------+-------+-------|
| 通用寄存器   | Accumulator         | ax    | eax   | rax   |
| 通用寄存器   | Base                | bx    | ebx   | rbx   |
| 通用寄存器   | Counter             | cx    | ecx   | rcx   |
| 通用寄存器   | Data                | dx    | edx   | rdx   |
| 指针寄存器   | Stack Pointer       | sp    | esp   | rsp   |
| 指针寄存器   | Base Pointer        | bp    | ebp   | rbp   |
| 变地址寄存器 | Source Index        | si    | esi   | rsi   |
| 变地址寄存器 | Destination Index   | di    | edi   | rdi   |
| 控制寄存器   | Instruction Pointer | ip    | eip   | rip   |
| 控制寄存器   | Flag                | flag  | eflag | eflag |
| 段寄存器     | Code Segment        | cs    | cs    | cs    |
| 段寄存器     | Data Segment        | ds    | ds    | ds    |
| 段寄存器     | Stack Segment       | ss    | ss    | ss    |
| 段寄存器     | Extra Segment       | es    | es    | es    |

[[file:../lab/01-register/main.S]]

操作示例
#+BEGIN_EXAMPLE
  info reg
  info reg eax
  p $esp

  layout asm
  layout reg
#+END_EXAMPLE

ubuntu 分清 32 位和 64 位, 如果是 64 为系统需要安装 32 为支持库
#+BEGIN_SRC sh
  apt install gcc-multilib
#+END_SRC

** 栈操作 push/pop
1. esp 指向栈的顶端
2. ebp 指向栈的基地址
3. push 操作时, esp = esp - 4, ebp 不变 (32b)
4. pop 操作时,  esp = esp + 4, ebp 不变

#+BEGIN_EXAMPLE
  origin:
     8 | 0x1 |
     7 | 0x2 | <- ebp  <-esp
     6 | 0x2 |
     5 | 0x2 |
     4 | 0x2 |
     3 | 0x2 |

  push: 操作后
     8 | 0x1 |
     7 | 0x2 | <- ebp
     6 | 0x0 |
     5 | 0x1 |
     4 | 0x0 |
     3 | 0x0 |        <-esp

  pop: 操作后
     8 | 0x1 |
     7 | 0x2 | <- ebp  <-esp
     6 | 0x0 |
     5 | 0x1 |
     4 | 0x0 |
     8 | 0x0 |
#+END_EXAMPLE

[[file:../lab/02-stack/main.S]]

.gdbinit 定义 hook, 设置 watch point
#+BEGIN_EXAMPLE
  define hook-stepi
    if $ebp > 0
      # printf "ebp=%p, esp=%p\n", $ebp, $esp
      x/4x $ebp-16
      x/i $eip
    end
  end

  starti
  watch $ebp
  watch $esp
#+END_EXAMPLE

** 分支跳转 jmp
通常汇编的跳转通过 ~cmp~, ~je~, ~jmp~ 等指令配合实现，例如
#+BEGIN_SRC asm
  jmp label
#+END_SRC

[[file:../lab/03-control-flow/jump.S]]

** 函数调用 call/ret
函数调用也属于简单的跳转指令, 例如
- call 调用函数
- ret 函数返回

[[file:../lab/03-control-flow/fcall.S]]

使用 gcc 编译的真实函数调用
#+BEGIN_SRC sh
  gcc -m32 -O0 adder.c -o adder.out
  objdump -d adder.out > adder.asm
#+END_SRC

[[file:../lab/03-control-flow/adder.c]]

#+BEGIN_SRC asm
  0000118d <add>:
      118d:	55                      push   %ebp
      118e:	89 e5                   mov    %esp,%ebp
      1190:	83 ec 10                sub    $0x10,%esp
      1193:	e8 49 00 00 00          call   11e1 <__x86.get_pc_thunk.ax>
      1198:	05 44 2e 00 00          add    $0x2e44,%eax
      119d:	8b 55 08                mov    0x8(%ebp),%edx
      11a0:	8b 45 0c                mov    0xc(%ebp),%eax
      11a3:	01 d0                   add    %edx,%eax
      11a5:	89 45 fc                mov    %eax,-0x4(%ebp)
      11a8:	8b 45 fc                mov    -0x4(%ebp),%eax
      11ab:	c9                      leave
      11ac:	c3                      ret

  000011ad <main>:
      11ad:	55                      push   %ebp
      11ae:	89 e5                   mov    %esp,%ebp
      11b0:	83 ec 10                sub    $0x10,%esp
      11b3:	e8 29 00 00 00          call   11e1 <__x86.get_pc_thunk.ax>
      11b8:	05 24 2e 00 00          add    $0x2e24,%eax
      11bd:	c7 45 f4 03 00 00 00    movl   $0x3,-0xc(%ebp)
      11c4:	c7 45 f8 04 00 00 00    movl   $0x4,-0x8(%ebp)
      11cb:	ff 75 f8                push   -0x8(%ebp)
      11ce:	ff 75 f4                push   -0xc(%ebp)
      11d1:	e8 b7 ff ff ff          call   118d <add>
      11d6:	83 c4 08                add    $0x8,%esp
      11d9:	89 45 fc                mov    %eax,-0x4(%ebp)
      11dc:	8b 45 fc                mov    -0x4(%ebp),%eax
      11df:	c9                      leave
      11e0:	c3                      ret
#+END_SRC

* QEMU 模拟器
** 什么是模拟器
1. [[https://www.qemu.org/][qemu]]
2. [[https://bochs.sourceforge.io/][bochs]]

操作系统：直接通过指令对硬件进行控制
#+BEGIN_EXAMPLE
  +============================================+
  ||  Operation System (操作系统): Linux, xv6 ||
  +============================================+
              |                    |
              |  Instruction(x86)  |
              v                    v
  +============================================+
  ||  Hardware(硬件): 硬盘，鼠标，显示器      ||
  +============================================+
#+END_EXAMPLE


模拟器：直接通过指令对硬件进行控制
#+BEGIN_EXAMPLE
  +============================================+
  || Host OS: Ubuntu                          ||
  ||                                          ||
  ||      +--------------------------------+  ||
  ||      | 调试操作系统: xv6-riscv        |  ||
  ||      +--------------------------------+  ||
  ||          |                     |         ||
  ||          |  Instruction(riscv) |         ||
  ||          V                     v         ||
  ||      +--------------------------------+  ||
  ||      | Simulator(模拟器): QEMU, Bochs |  ||
  ||      |    作为软件运行在宿主机器      |  ||
  ||      +--------------------------------+  ||
  ||              |                           ||
  ||              | 宿主操作系统指令(x86)     ||
  ||              |                           ||
  ||              V                           ||
  +============================================+
              |                    |
              |  Instruction(x86)  |
              v                    v
  +============================================+
  ||  Hardware(硬件): 硬盘，鼠标，显示器      ||
  +============================================+
#+END_EXAMPLE

** 操作系统启动过程
1. ~启动 BIOS~ Basic Input/Output System，基本输入输出系统。
   1) =供电初始化= 按下电源开关后，电源就开始给主板和其他设备供电，CPU 会把所有寄
      存器的值都设为默认值，即恢复初始状态。随后 CPU 会执行初始位置的指令，跳转到
      BIOS 启动代码位置，开始启动 BIOS。
   2) =POST 硬件自检= BIOS 首先进行 POST（Power On Self Test，硬件自检），检查计算
      机硬件是否满足运行的基本条件，并完成相应的初始化工作。如果发现了问题，主板会
      发出不同的蜂鸣声表示不同的问题。
   3) =搜索可引导的存储设备= BIOS 按照启动顺序开始搜索可引导的存储设备，找到后，会
      将存储设备中的引导扇区读入物理内存，并执行引导扇区中的程序，开始系统引导。
   4) BIOS 是按照顺序依次搜索可引导的存储设备的，这个顺序就叫启动顺序（Boot
      Sequence），可以在 BIOS 中进行查看和修改。
2. ~系统引导~
   1) =读取 MBR= 读取并执行硬盘的第一个扇区，即 MBR（Master Boot Record，主引导记
      录，大小为 512 字节）。其作用为告诉计算机到硬盘的哪一个位置去找操作系统。MBR
      的结构如下：
      + 第 1-446 字节：调用操作系统的机器码，可以被 CPU 直接执行
      + 第 447-510 字节：分区表（Partition Table），将硬盘分为了若干个分区
      + 第 511-512 字节：记录签名（0x55 和 0xAA），表示设备可以用于启动
   2) =查找活动分区= 搜索 MBR 中的分区表，找到唯一的活动分区（Active Partition），
      并将活动分区的第一个扇区中的引导扇区（称为 卷引导记录，Volume Boot Record，
      VBR）读入内存，就能找到操作系统在这个分区中的位置。然后，计算机就会开始加载
      操作系统了。
3. ~启动系统~ 由于一台计算机中可以安装多个操作系统，所以启动系统时也会有不同的情
   况。当有多个操作系统时，会运行启动管理器（Boot Loader），让用户选择启动操作系
   统； 当只有一个操作系统时，就会直接从激活分区中启动操作系统（当然也可以选择将
   控制权交 给启动管理器，boot loader 可以存在 MBR 中，也可以存在主分区的引导扇
   区中）。
4. ~初始化系统~ 操作系统启动后，控制权就从 boot loader 转交给了操作系统，之后，
   操作系统的内核首先被载入缓存，随后会运行初始化进程进行操作系统的初始化。

至此，整个计算机的启动过程就完成了。

** 普通启动
存储设备
1. 软盘 -fda
2. 硬盘 -hda
3. 光盘介质 -cdrom
#+BEGIN_SRC sh
  man qemu
#+END_SRC

启动 linux 0.11 系统
1. 指定软盘 Image
2. 指定硬盘 hdc-0.11.img
3. -boot a 表示从软盘启动,  man qemu ... /-boot
#+BEGIN_SRC sh
  qemu-system-i386 -boot a -fda Image -hda hdc-0.11.img
#+END_SRC

启动 xv6, 控制系统硬件参数
1. -smp CPU 数据
2. -m   内存大小
3. -nographic 表示不启动图形界面, 无图形界面的常用快捷键如下：
   + =ctrl-a x= 退出 qemu
   + =ctrl-a c= 切换串口
   + =ctrl-a h= 帮助
#+BEGIN_SRC sh
  qemu-system-i386 -smp 2 -m 512 -nographic -hda xv6.img -hdb fs.img
#+END_SRC

另外存储驱动也可以使用下面方法指定
#+BEGIN_SRC sh
  qemu-system-i386 -smp 2 -m 512 -nographic \
      -drive file=fs.img,index=1,media=disk,format=raw \
      -drive file=xv6.img,index=0,media=disk,format=raw
#+END_SRC

** initrd 启动
initrd 全称是 initial RAM disk ，它提供一种让核心可以简单使用 Ramdisk 的能力
1. 格式化一个 Ramdisk
2. 加载文件系统内容到 Ramdisk
3. 将 Ramdisk 作为根文件系统

MINIX 3 的 initrd 启动
#+BEGIN_SRC sh
  cd /data/os/minix/obj.i386/work
  qemu-system-i386 \
      --enable-kvm \
      -m 1G \
      -kernel kernel \
      -append "bootramdisk=1" \
      -initrd "mod01_ds,mod02_rs,mod03_pm,mod04_sched,mod05_vfs,mod06_memory,mod07_tty,mod08_mib,mod09_vm,mod10_pfs,mod11_mfs,mod12_init"
#+END_SRC

Linux 内核启动方式
#+BEGIN_SRC sh
  cd /data/os/x86_64/buildroot-2023.02.5/output/images

  qemu-system-x86_64 \
      -M pc \
      -nographic \
      -kernel bzImage \
      -drive file=rootfs.ext2,if=virtio,format=raw \
      -append "rootwait root=/dev/vda console=tty1 console=ttyS0" \
      -net nic,model=virtio -net user
#+END_SRC

** GDB 调试 XV6
qemu 通过 gdb server 来支持 gdb 调试，启动时需要添加下面选项来开启调试
1. -S 启动时不要立即执行 CPU 指令，等待 c 命令
2. -s 开启 gdb 监听端口 1234, 这样 gdb 可以使用下面命令来链接到 qemu
   #+BEGIN_EXAMPLE
     (gdb) target remote :1234
   #+END_EXAMPLE
3. -s 也可以是 ~-gdb tcp::1234~ 的简写，也可以制定其他端口

以 xv6-public 为例，通过 make qemu-nox-gdb 可以开启调试
#+BEGIN_SRC sh
  sed "s/localhost:1234/localhost:26000/" < .gdbinit.tmpl > .gdbinit
  qemu-system-i386 \
      -nographic -drive file=fs.img,index=1,media=disk,format=raw \
      -drive file=xv6.img,index=0,media=disk,format=raw -smp 2 -m 512 \
      -S -gdb tcp::26000
#+END_SRC

** 模拟器的优缺点
1. 优点
   - 方便快捷，无需重启电脑
   - 可以作为 gdb server 来调试
   - 提供了丰富的调试命令, info regs, info tlb
   - 支持多架构 x86, riscv, arm, mips 等
   - 开源免费
2. 缺点
   - 模拟器性能会有一些损耗

* 编写最小操作系统
** 中断，陷阱和系统调用
中断(Interrupt) 是指 CPU 停下当前的工作任务，去处理其他事情，处理完后回来继续执
行刚才的任务 [[https://stanislavs.org/helppc/idx_interrupt.html][Interrupt Services]]
1. 中断是硬件实现的基础功能
2. x86 架构中有中断描述符表 IDT
3. BIOS 提供了一些基础中断，可以类似函数功能调用
   - 读写磁盘 ~int 0x13~, 其中详细的中断参数见 [[https://stanislavs.org/helppc/int_13-2.html][link]]
   - 输出字符

陷阱(Trap)：是一种有意的，预先安排的异常事件
1. 一般是在编写程序时故意设下的陷阱指令，而后执行到陷阱指令后，CPU 将会调用特定程
   序进行相应的处理，处理结束后返回到陷阱指令的下一条指令
2. 如系统调用，程序调试功能等, 最常见的就是 Linux 系统调用的实现，使用中断指令
   ~int 0x80~

系统调用(System Call) 指操作系统提供给应用的一组 API 函数， Linux 系统调用见
arch/x86/entry/syscalls/syscall_32.tbl
#+BEGIN_EXAMPLE
  #
  # 32-bit system call numbers and entry vectors
  #
  # The format is:
  # <number> <abi> <name> <entry point> <compat entry point>
  #
  # The __ia32_sys and __ia32_compat_sys stubs are created on-the-fly for
  # sys_*() system calls and compat_sys_*() compat system calls if
  # IA32_EMULATION is defined, and expect struct pt_regs *regs as their only
  # parameter.
  #
  # The abi is always "i386" for this file.
  #
  0	i386	restart_syscall		sys_restart_syscall
  1	i386	exit			sys_exit
  2	i386	fork			sys_fork
  3	i386	read			sys_read
  4	i386	write			sys_write
  5	i386	open			sys_open			compat_sys_open
  6	i386	close			sys_close

  .....
#+END_EXAMPLE

** 分段
8086 寄存器是 16 位的, 真实地址 = 段地址 << 4 + address
#+BEGIN_SRC asm
  ;;; 设置 ds 段寄存器
  mov bx, 0x7c0
  mov ds, bx
  ;;; 默认使用 ds 段寄存器作为基地址
  mov al, [msg]
  int 0x10

  ;;; 使用 es 段寄存器进行寻址
  mov bx, 0x7c0
  mov es, bx
  mov al, [es:the_secret]
  int 0x10
#+END_SRC

** GDT
1. GDT 主要保护以下信息, 总共 64 位, [[https://files.osdev.org/mirrors/geezer/os/pm.htm][link]]
   - base  = low(16) + middle(8) + high(8)
   - limit = low(16) + high(4)
   - flags = (12)
2. GDT 的第一项必须全是 ~0x00~
3. GDT 加载通过 ~lgdt~ 指令

下面是一个初始化的 gdt 内存定义，这里先将代码段和数据段合并在一起
#+BEGIN_SRC asm
  gdt_start: ; don't remove the labels, they're needed to compute sizes and jumps
      ; the GDT starts with a null 8-byte
      dd 0x0 ; 4 byte
      dd 0x0 ; 4 byte

  ; GDT for code segment. base = 0x00000000, length = 0xfffff
  gdt_code:
      dw 0xffff    ; segment length, bits 0-15                    | limit_low(16)
      dw 0x0       ; segment base, bits 0-15                      | base_low(16)
      db 0x0       ; segment base, bits 16-23                     | base_middle(8)
      db 10011010b ; flags (8 bits)                               | flags1(8)
      db 11001111b ; flags (4 bits) + segment length, bits 16-19  | limit_high(4), flags2(4)
      db 0x0       ; segment base, bits 24-31                     | base_high(8)

  gdt_data:
      dw 0xffff
      dw 0x0
      db 0x0
      db 10010010b
      db 11001111b
      db 0x0

  gdt_end:

  ; GDT descriptor, via lgdt [gdt_descriptor]
  gdt_descriptor:
      dw gdt_end - gdt_start - 1 ; size (16 bit), always one less of its true size
      dd gdt_start               ; address (32 bit)

  ; define some constants for later use
  CODE_SEG equ gdt_code - gdt_start
  DATA_SEG equ gdt_data - gdt_start
#+END_SRC

** 实模式到保护模式切换
1. 关闭中断
2. 加载 gdt
3. 设置控制寄存器 ~cr0~
4. 通过远程调整来 flush 流水线
5. 更新所以的段寄存器
6. 更新系统栈
7. 跳转到 32 位指令出执行

#+BEGIN_SRC asm
  ;;; real mode
  [bits 16]
  switch_to_pm:
      cli                         ; 1. disable interrupts
      lgdt [gdt_descriptor]       ; 2. load the GDT descriptor
      mov eax, cr0
      or eax, 0x1                 ; 3. set 32-bit mode bit in cr0
      mov cr0, eax
      jmp CODE_SEG:init_pm        ; 4. far jump by using a different segment

  ;;; protected mode is enabled
  [bits 32]
  init_pm:
      mov ax, DATA_SEG            ; 5. update the segment registers
      mov ds, ax
      mov ss, ax
      mov es, ax
      mov fs, ax
      mov gs, ax

      mov ebp, 0x90000            ; 6. update the stack right at the top of the free space
      mov esp, ebp

      call BEGIN_PM               ; 7. Call a well-known label with useful code
#+END_SRC
