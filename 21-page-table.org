#+TITLE: 分页及 xv6 页表初始化
#+AUTHOR: Jinghui Hu
#+EMAIL: hujinghui@buaa.edu.cn
#+DATE: <2023-11-06 Mon>
#+STARTUP: overview num indent
#+OPTIONS: ^:nil


* 分页机制
1. 内核和用户的代码都是 virtual address
2. 页目录和页表中包含 1024 个目录项 PTE (page table entry)
   - PPN (physical page number), 20 位的物理页码
   - Flags, 12 位
3. 第一步从 cr3 寄存器中获取页目录 page directory
4. va.dir 索引 page directory 获取到页表 page table
5. page directory / page table 包含 1024 个 PTE
   - 这段连续内存大小位 1024 * 4 byte = 4KB
   - 这 4KB 又叫页 page
6. va.table 索引 page table 获取到物理地址到 PPN
#+BEGIN_EXAMPLE
                              +--------------------------------------------+
                              |                                            |
  Virtual Address             |                Physical Address            v
  +----------------------------------+         +----------------------------------+
  | Dir(10) | Table(10) | Offset(12) |         | PPN (20)            | Offset(12) |
  +----------------------------------+         +----------------------------------+
      |          |                                 ^
      |          |                                 |
      |          |                                 |
      |          |                       1023 |----+---------------|
      |          |                            |    |    |          |
      |          |                            | PPN(20) | Flag(12) |
      |          |                            |         |          |
      |          |                            | 0x81    |          |
      |          +----------------------->  2 | 0x43    |          |
      |                                     1 | 0       |          |
      |            +--------------------->  0 |--------------------|
      |            |                                 PAGE TABLE
      |            |
      |            |
      |            |                                      1023 |------------|
      |  1023 |----+---------------|                           |     |      |
      |       |    |    |          |                           | PPN | Flag |
      |       | PPN(20) | Flag(12) |                           |     |      |
      |       |         |          |                         2 |     |      |
      |       |         |          |                         1 | 0   |      |
      `-->  2 | 0x23 ---+----------+---------------------->  0 |------------|
            1 | 0x10    |          |
  cr3 --->  0 |--------------------|
                  PAGE DIRECTORY
#+END_EXAMPLE

* x86 的寻址模式
1. 虚拟地址/逻辑地址 logic address
   - 编译器产生的地址
2. 线性地址 linear address
   - CPU 加载程序后，会为这个程序分配内存，通过分段产生的地址
   - 段基址 + 逻辑地址 = 线性地址
3. 物理地址 physical address
   - 硬件真实的内存地址
   - 如果没有开启分页, pa = la
   - 开启分页后，la 经过硬件转换才能得到 pa

#+BEGIN_EXAMPLE
       [  CPU  ]
         |   |
         |   |  (Logic Address)
         |   |
         v   v
  [Segment Translation] (Selector/Offset/gdtr)
         |   |
         |   |  (Linear Address)
         |   |
         v   v
  [  Page Translation ] (Paging/cr3/PD/PT)
         |   |
         |   |  (Physical Address)
         |   |
         v   v
      [  Memory  ]
#+END_EXAMPLE

* entry.S 阶段分页机制分析
xv6 在 entry.S 中开启分页

启用分页机制需要完成下面三步
1. 准备好页目录表和页表
2. 将页表地址写入控制寄存器 cr3
3. 将寄存器 cr0 的 PG 位置 1

[[file:../../study/os/xv6-public/entry.S]]

该阶段使用 CR4_PSE 的 4M 大页映射，通过 qemu 验证开启分页后
#+BEGIN_EXAMPLE
  (qemu) help info tlb
  info tlb  -- show virtual to physical memory mappings
  (qemu) help info mem
  info mem  -- show the active virtual memory mappings
  (qemu) info tlb
  0000000000000000: 0000000000000000 --P-A---W
  0000000080000000: 0000000000000000 --P-----W
  (qemu) info mem
  0000000000000000-0000000000400000 0000000000400000 -rw
  0000000080000000-0000000080400000 0000000000400000 -rw
  (qemu)
#+END_EXAMPLE

gdb 调试分页
#+BEGIN_EXAMPLE
  (gdb) b main
  Breakpoint 2 at 0x80103060: file main.c, line 20.
  (gdb) c
  Continuing.
  => 0x80103060 <main>:   lea    0x4(%esp),%ecx

  Thread 1 hit Breakpoint 2, main () at main.c:20
  20        kinit1(end, P2V(4*1024*1024)); // phys page allocator
  (gdb) info reg cr3
  cr3            0x109000            [ PDBR=265 PCID=0 ]
  (gdb) x/8x 0x109000
  0x109000:       0x000000a3      0x00000000      0x00000000      0x00000000
  0x109010:       0x00000000      0x00000000      0x00000000      0x00000000
  (gdb) p *(int *)0x109000
  $1 = 163
  (gdb) p/x *(int *)0x109000
  $2 = 0xa3
  (gdb) p/t *(int *)0x109000
  $3 = 10100011
  (gdb)
#+END_EXAMPLE

查看手册，获取 ~extern char end[];~ 细节
#+BEGIN_SRC sh
  man 3 end
#+END_SRC

* kvmalloc 设置正式分页阶段
1. kinit1 初始化内存
   - kmem.freelist 初始化链表
2. kvmalloc 初始化内存页表，核心调研 setupkvm 初始化内核分页表
   - kalloc 申请 4K 物理页
     1) pgdir 页目录
   - memset 设置内存值
   - mappages 初始化页表项, 初始化 kmap
     1. walkpgdir 创建页表项
     2. 设置权限
#+BEGIN_EXAMPLE
  (gdb) p pgdir
  $10 = (pde_t *) 0x803ff000
  (gdb) x/8x 0x803ff000
  0x803ff000:     0x803fe000      0x01010101      0x01010101      0x01010101
  0x803ff010:     0x01010101      0x01010101      0x01010101      0x01010101
  (gdb) set print array on
  (gdb) p/x kmap
  $4 = {
    {virt = 0x80000000, phys_start = 0x0, phys_end = 0x100000, perm = 0x2},
    {virt = 0x80100000, phys_start = 0x100000, phys_end = 0x108000, perm = 0x0},
    {virt = 0x80108000, phys_start = 0x108000, phys_end = 0xe000000, perm = 0x2},
    {virt = 0xfe000000, phys_start = 0xfe000000, phys_end = 0x0, perm = 0x2}
  }
  (gdb)
#+END_EXAMPLE

* 物理内存分布
1. 0x0 ~ 0x100000: BIOS 地址空间 (total 1MB)
   - 0x7c00 ~ 0x7e00 MBR
   - 0xa0000 ~ 0x100000 device memory region
2. EXTMEM(0x100000) ~ end: BIOS extended memory start
   - kernel text+data
   - end 0x1154d0 in main.c
4. end ~ PHYSTOP(0xe000000): Free Memory
   - end ~ 4M kinit1 初始化
   - PHYSTOP 物理内存终点
5. DEVSPACE(0xfe000000) ~ 4G: Memory-mapped 32-bit I/O Devices
   - DEVSPACE memory mapped direct
   - devices such as ioapic
