#+TITLE: 中断调用流程
#+AUTHOR: Jinghui Hu
#+EMAIL: hujinghui@buaa.edu.cn
#+DATE: <2023-11-16 Thu>
#+STARTUP: overview num indent
#+OPTIONS: ^:nil
#+PROPERTY: header-args:sh :results output :dir ../../study/os/xv6-public


* int 指令
在 x86 中，中断处理程序的入口在中断描述符表(IDT)中被定义。这个表有 256 个表项，
每一个都提供了相应的 cs 和 eip

程序进行一个系统调用，它需要调用 int n 指令，这里 n 就是 IDT 的索引
#+BEGIN_SRC asm
  int 0x40
#+END_SRC

~int~ 指令进行下面一些步骤：
1. 从 IDT 中获得第 n 个描述符，n 就是 int 的参数
2. 检查 cs 的域 CPL <= DPL，DPL 是描述符中记录的特权级
3. 如果目标段选择符的 PL < CPL，就在 CPU 内部的寄存器中保存 esp 和 ss 的值
4. 从一个 TSS 任务段描述符中加载 ss 和 esp, 记做 esp0
5. push ss
6. push esp
7. push eflags
8. push cs
9. push eip
10. 清除 eflags 的一些位
11. 设置 cs 和 eip 为描述符中的值

#+BEGIN_EXAMPLE
                     | ?????? | <- esp0 from TSS
  Present on       / | ss     |
  privilege change \ | esp    |
                     | eflags |
                     | cs     |
                     | eip    |
                     | errno  | <- esp
                     |        |
                     |        |
#+END_EXAMPLE

操作系统可以使用 ~iret~ 指令来从一个 ~int~ 指令中返回
- 它从栈中弹出 ~int~ 指令保存的值
- 然后通过恢复保存的 eip 的值来继续用户程序的执行

* tvinit 初始中断向量 IDT
1. 设置了 IDT 表中的 256 个表项
   - 中断 i 的处理向量为 vectors[i]
   - 0x40 设置成系统调用 T_SYSCALL
   - 中断映射定义 [[file:../../study/os/xv6-public/traps.h]]
2. xv6 中断编号
   - 0-31  软件中断: divide error、 page fault
   - 32-63 硬件中断
   - 64    系统调用: syscall
3. syscall 特殊处理
   - 设置 trap 位为 1 指定 syscall 时陷阱门，即处理系统调用时可以同时处理其它中断
   - 设置 syscall 调用权限 DPL_USER，阻止用户程序产生其它中断
     1) 例如用户不能产生设备中断
     2) 如果用户产生不合法的中断，会抛出 general protection fault, 即 int 13
4. 特权等级切换
   - 用户态切换内核态，内核不能使用用户的堆栈，可能存在恶意攻击
   - 内核态切换用户态，从 TSS 中恢复用户堆栈，见 switchuvm

* initcode 的系统调用流程分析
1. int 0x40 => 跳转到中断处理向量
   - vector64
     #+BEGIN_SRC asm
       vector64:
         pushl $0
         pushl $64
         jmp alltraps
     #+END_SRC
   - vector64 跳转 alltraps
2. alltraps 是所有 trap 的入口
   - 设置 trapframe
   - 修改寄存器
   - 返回内核态, ~call trap~
3. trap 中判断系统调用 syscall()
4. syscall 处理系统调用
   - 获取当前执行进程
   - 从系统调用表 syscalls 中调用系统调用函数 sys_exec
5. sys_exec
   - 检查
   - 获取 argv
   - 调用 exec
6. exec
