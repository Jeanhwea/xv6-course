#+TITLE: 中断介绍
#+AUTHOR: Jinghui Hu
#+EMAIL: hujinghui@buaa.edu.cn
#+DATE: <2023-11-16 Thu>
#+STARTUP: overview num indent
#+OPTIONS: ^:nil
#+PROPERTY: header-args:sh :results output :dir ../../study/os/xv6-public

* int 指令
在 x86 中，中断处理程序的入口在中断描述符表(IDT)中被定义。这个表有 256 个表项，每
一个都提供了相应的 cs 和 eip

程序进行一个系统调用，它需要调用 int n 指令，这里 n 就是 IDT 的索引
#+BEGIN_SRC asm
  int 0x40
#+END_SRC

int 指令进行下面一些步骤：
1. 从 IDT 中获得第 n 个描述符，n 就是 int 的参数
2. 检查 cs 的域 CPL <= DPL，DPL 是描述符中记录的特权级
3. 如果目标段选择符的 PL < CPL，就在 CPU 内部的寄存器中保存 esp 和 ss 的值
4. 从一个 TSS 任务段描述符中加载 ss 和 esp
5. push ss
6. push esp
7. push eflags
8. push cs
9. push eip
10. 清除 eflags 的一些位
11. 设置 cs 和 eip 为描述符中的值

* tvinit 初始中断向量 IDT
1. 设置了 IDT 表中的 256 个表项
   - 中断 i的处理向量为 vectors[i]
   - 0x40 设置成系统调用 T_SYSCALL

* initcode 的系统调用流程分析
1. int 0x40 => 跳转到中断处理向量
   - vector64
     #+BEGIN_SRC asm
       vector64:
         pushl $0
         pushl $64
         jmp alltraps
     #+END_SRC
   - vector64 跳转 alltraps
2. alltraps 是所有 trap 的入口
   - 设置 trapframe
   - 修改寄存器
   - 返回内核态, ~call trap~
3. trap 中判断系统调用 syscall()
4. syscall 处理系统调用
   - 获取当前执行进程
   - 从系统调用表 syscalls 中调用系统调用函数 sys_exec
5. sys_exec
   - 检查
   - 获取 argv
   - 调用 exec
6. exec

* exec() 系统调用
#+BEGIN_SRC c
  void exec(init, argv)
#+END_SRC

1. 创建用户地址空间
2. 从磁盘加载 path 文件, 到内存中
   - 打开文件, namei
   - 读取 ELF 头, readi
     #+BEGIN_SRC sh :results output :exports both
       readelf -h _init
     #+END_SRC

     #+RESULTS:
     #+begin_example
     ELF Header:
       Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00
       Class:                             ELF32
       Data:                              2's complement, little endian
       Version:                           1 (current)
       OS/ABI:                            UNIX - System V
       ABI Version:                       0
       Type:                              EXEC (Executable file)
       Machine:                           Intel 80386
       Version:                           0x1
       Entry point address:               0x0
       Start of program headers:          52 (bytes into file)
       Start of section headers:          14252 (bytes into file)
       Flags:                             0x0
       Size of this header:               52 (bytes)
       Size of program headers:           32 (bytes)
       Number of program headers:         2
       Size of section headers:           40 (bytes)
       Number of section headers:         18
       Section header string table index: 17
     #+end_example
   - 解析代码段, readi/allocuvm/loaduvm
     #+BEGIN_SRC sh :results output :exports both
       readelf -l _init
     #+END_SRC

     #+RESULTS:
     #+begin_example

     Elf file type is EXEC (Executable file)
     Entry point 0x0
     There are 2 program headers, starting at offset 52

     Program Headers:
       Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align
       LOAD           0x000080 0x00000000 0x00000000 0x00b2c 0x00b38 RWE 0x10
       GNU_STACK      0x000000 0x00000000 0x00000000 0x00000 0x00000 RWE 0x10

      Section to Segment mapping:
       Segment Sections...
        00     .text .rodata .eh_frame .data .bss
        01
     #+end_example
3. 申请用户堆栈页面, allocuvm
4. 设置参数 args, 准备堆栈, copyout
5. 提交用户态，跳转用户态, switchuvm
   - elf.entry
   - pgdir
   - eip/esp
