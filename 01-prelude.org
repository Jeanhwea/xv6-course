#+TITLE: x86 体系结构及系统启动
#+AUTHOR: Jinghui Hu
#+EMAIL: hujinghui@buaa.edu.cn
#+DATE: <2023-10-27 Fri>
#+STARTUP: overview num indent

* x86 体系结构
** 寄存器及编译流程
| 分类         | 英文全称            | 16 位 | 32 位 | 64 位 |
|--------------+---------------------+-------+-------+-------|
| 通用寄存器   | Accumulator         | ax    | eax   | rax   |
| 通用寄存器   | Base                | bx    | ebx   | rbx   |
| 通用寄存器   | Counter             | cx    | ecx   | rcx   |
| 通用寄存器   | Data                | dx    | edx   | rdx   |
| 指针寄存器   | Stack Pointer       | sp    | esp   | rsp   |
| 指针寄存器   | Base Pointer        | bp    | ebp   | rbp   |
| 变地址寄存器 | Source Index        | si    | esi   | rsi   |
| 变地址寄存器 | Destination Index   | di    | edi   | rdi   |
| 控制寄存器   | Instruction Pointer | ip    | eip   | rip   |
| 控制寄存器   | Flag                | flag  | eflag | eflag |
| 段寄存器     | Code Segment        | cs    | cs    | cs    |
| 段寄存器     | Data Segment        | ds    | ds    | ds    |
| 段寄存器     | Stack Segment       | ss    | ss    | ss    |
| 段寄存器     | Extra Segment       | es    | es    | es    |

[[file:lab/01-register/main.S]]

操作示例
#+BEGIN_EXAMPLE
  info reg
  info reg eax
  p $esp

  layout asm
  layout reg
#+END_EXAMPLE

ubuntu 分清 32 位和 64 位, 如果是 64 为系统需要安装 32 为支持库
#+BEGIN_SRC sh
  apt install gcc-multilib
#+END_SRC

** 栈操作 push/pop
1. esp 指向栈的顶端
2. ebp 指向栈的基地址
3. push 操作时, esp = esp - 4, ebp 不变 (32b)
4. pop 操作时,  esp = esp + 4, ebp 不变

#+BEGIN_EXAMPLE
  origin:
     addr      data
     0x0008 |   1 |
     0x0007 |   0 | <- ebp  <-esp
     0x0006 |   0 |
     0x0005 |   2 |
     0x0004 |   2 |
     0x0003 |   2 |

  push: 操作后
     addr     data
     0x0008 |   1 |
     0x0007 |   0 | <- ebp
     0x0006 |   0 |
     0x0005 |   2 |
     0x0004 |   2 |
     0x0003 |   2 |        <-esp

  pop: 操作后
     addr     data
     0x0008 |   1 |
     0x0007 |   0 | <- ebp <-esp
     0x0006 |   0 |
     0x0005 |   2 |
     0x0004 |   2 |
     0x0003 |   2 |
#+END_EXAMPLE

[[file:lab/02-stack/main.S]]

.gdbinit 定义 hook, 设置 watch point
#+BEGIN_EXAMPLE
  define hook-stepi
    if $ebp > 0
      # printf "ebp=%p, esp=%p\n", $ebp, $esp
      x/4x $ebp-16
      x/i $eip
    end
  end

  starti
  watch $ebp
  watch $esp
#+END_EXAMPLE

** 分支跳转 jmp
通常汇编的跳转通过 ~cmp~, ~je~, ~jmp~ 等指令配合实现，例如
#+BEGIN_SRC asm
  jmp label
#+END_SRC

[[file:lab/03-control-flow/jump.S]]

** 函数调用 call/ret
函数调用也属于简单的跳转指令, 例如
- call 调用函数
- ret 函数返回

[[file:lab/03-control-flow/fcall.S]]

使用 gcc 编译的真实函数调用
#+BEGIN_SRC sh
  gcc -m32 -O0 adder.c -o adder.out
  objdump -d adder.out > adder.asm
#+END_SRC

[[file:lab/03-control-flow/adder.c]]

#+BEGIN_SRC asm
  0000118d <add>:
      118d:	55                      push   %ebp
      118e:	89 e5                   mov    %esp,%ebp
      1190:	83 ec 10                sub    $0x10,%esp
      1193:	e8 49 00 00 00          call   11e1 <__x86.get_pc_thunk.ax>
      1198:	05 44 2e 00 00          add    $0x2e44,%eax
      119d:	8b 55 08                mov    0x8(%ebp),%edx
      11a0:	8b 45 0c                mov    0xc(%ebp),%eax
      11a3:	01 d0                   add    %edx,%eax
      11a5:	89 45 fc                mov    %eax,-0x4(%ebp)
      11a8:	8b 45 fc                mov    -0x4(%ebp),%eax
      11ab:	c9                      leave
      11ac:	c3                      ret

  000011ad <main>:
      11ad:	55                      push   %ebp
      11ae:	89 e5                   mov    %esp,%ebp
      11b0:	83 ec 10                sub    $0x10,%esp
      11b3:	e8 29 00 00 00          call   11e1 <__x86.get_pc_thunk.ax>
      11b8:	05 24 2e 00 00          add    $0x2e24,%eax
      11bd:	c7 45 f4 03 00 00 00    movl   $0x3,-0xc(%ebp)
      11c4:	c7 45 f8 04 00 00 00    movl   $0x4,-0x8(%ebp)
      11cb:	ff 75 f8                push   -0x8(%ebp)
      11ce:	ff 75 f4                push   -0xc(%ebp)
      11d1:	e8 b7 ff ff ff          call   118d <add>
      11d6:	83 c4 08                add    $0x8,%esp
      11d9:	89 45 fc                mov    %eax,-0x4(%ebp)
      11dc:	8b 45 fc                mov    -0x4(%ebp),%eax
      11df:	c9                      leave
      11e0:	c3                      ret
#+END_SRC

* QEMU 模拟器
** 什么是模拟器
1. [[https://www.qemu.org/][qemu]]
2. [[https://bochs.sourceforge.io/][bochs]]

操作系统：直接通过指令对硬件进行控制
#+BEGIN_EXAMPLE
  +============================================+
  ||  Operation System (操作系统): Linux, xv6 ||
  +============================================+
              |                    |
              |  Instruction(x86)  |
              v                    v
  +============================================+
  ||  Hardware(硬件): 硬盘，鼠标，显示器      ||
  +============================================+
#+END_EXAMPLE


模拟器：直接通过指令对硬件进行控制
#+BEGIN_EXAMPLE
  +============================================+
  || Host OS: Ubuntu                          ||
  ||                                          ||
  ||      +--------------------------------+  ||
  ||      | 调试操作系统: xv6-riscv        |  ||
  ||      +--------------------------------+  ||
  ||          |                     |         ||
  ||          |  Instruction(riscv) |         ||
  ||          V                     v         ||
  ||      +--------------------------------+  ||
  ||      | Simulator(模拟器): QEMU, Bochs |  ||
  ||      |    作为软件运行在宿主机器      |  ||
  ||      +--------------------------------+  ||
  ||              |                           ||
  ||              | 宿主操作系统指令(x86)     ||
  ||              |                           ||
  ||              V                           ||
  +============================================+
              |                    |
              |  Instruction(x86)  |
              v                    v
  +============================================+
  ||  Hardware(硬件): 硬盘，鼠标，显示器      ||
  +============================================+
#+END_EXAMPLE

** 操作系统启动过程
1. ~启动 BIOS~ Basic Input/Output System，基本输入输出系统。
   1) =供电初始化= 按下电源开关后，电源就开始给主板和其他设备供电，CPU 会把所有寄
      存器的值都设为默认值，即恢复初始状态。随后 CPU 会执行初始位置的指令，跳转到
      BIOS 启动代码位置，开始启动 BIOS。
   2) =POST 硬件自检= BIOS 首先进行 POST（Power On Self Test，硬件自检），检查计算
      机硬件是否满足运行的基本条件，并完成相应的初始化工作。如果发现了问题，主板会
      发出不同的蜂鸣声表示不同的问题。
   3) =搜索可引导的存储设备= BIOS 按照启动顺序开始搜索可引导的存储设备，找到后，会
      将存储设备中的引导扇区读入物理内存，并执行引导扇区中的程序，开始系统引导。
   4) BIOS 是按照顺序依次搜索可引导的存储设备的，这个顺序就叫启动顺序（Boot
      Sequence），可以在 BIOS 中进行查看和修改。
2. ~系统引导~
   1) =读取 MBR= 读取并执行硬盘的第一个扇区，即 MBR（Master Boot Record，主引导记
      录，大小为 512 字节）。其作用为告诉计算机到硬盘的哪一个位置去找操作系统。MBR
      的结构如下：
      + 第 1-446 字节：调用操作系统的机器码，可以被 CPU 直接执行
      + 第 447-510 字节：分区表（Partition Table），将硬盘分为了若干个分区
      + 第 511-512 字节：记录签名（0x55 和 0xAA），表示设备可以用于启动
   2) =查找活动分区= 搜索 MBR 中的分区表，找到唯一的活动分区（Active Partition），
      并将活动分区的第一个扇区中的引导扇区（称为 卷引导记录，Volume Boot Record，
      VBR）读入内存，就能找到操作系统在这个分区中的位置。然后，计算机就会开始加载
      操作系统了。
3. ~启动系统~ 由于一台计算机中可以安装多个操作系统，所以启动系统时也会有不同的情
   况。当有多个操作系统时，会运行启动管理器（Boot Loader），让用户选择启动操作系
   统； 当只有一个操作系统时，就会直接从激活分区中启动操作系统（当然也可以选择将
   控制权交 给启动管理器，boot loader 可以存在 MBR 中，也可以存在主分区的引导扇
   区中）。
4. ~初始化系统~ 操作系统启动后，控制权就从 boot loader 转交给了操作系统，之后，
   操作系统的内核首先被载入缓存，随后会运行初始化进程进行操作系统的初始化。

至此，整个计算机的启动过程就完成了。

** 普通启动
存储设备
1. 软盘 -fda
2. 硬盘 -hda
3. 光盘介质 -cdrom
#+BEGIN_SRC sh
  man qemu
#+END_SRC

启动 linux 0.11 系统
1. 指定软盘 Image
2. 指定硬盘 hdc-0.11.img
3. -boot a 表示从软盘启动,  man qemu ... /-boot
#+BEGIN_SRC sh
  qemu-system-i386 -boot a -fda Image -hda hdc-0.11.img
#+END_SRC

启动 xv6, 控制系统硬件参数
1. -smp CPU 数据
2. -m   内存大小
3. -nographic 表示不启动图形界面, 无图形界面的常用快捷键如下：
   + =ctrl-a x= 退出 qemu
   + =ctrl-a c= 切换串口
   + =ctrl-a h= 帮助
#+BEGIN_SRC sh
  qemu-system-i386 -smp 2 -m 512 -nographic -hda xv6.img -hdb fs.img
#+END_SRC

另外存储驱动也可以使用下面方法指定
#+BEGIN_SRC sh
  qemu-system-i386 -smp 2 -m 512 -nographic \
      -drive file=fs.img,index=1,media=disk,format=raw \
      -drive file=xv6.img,index=0,media=disk,format=raw
#+END_SRC

** initrd 启动
initrd 全称是 initial RAM disk ，它提供一种让核心可以简单使用 Ramdisk 的能力
1. 格式化一个 Ramdisk
2. 加载文件系统内容到 Ramdisk
3. 将 Ramdisk 作为根文件系统

MINIX 3 的 initrd 启动
#+BEGIN_SRC sh
  cd /data/os/minix/obj.i386/work
  qemu-system-i386 \
      --enable-kvm \
      -m 1G \
      -kernel kernel \
      -append "bootramdisk=1" \
      -initrd "mod01_ds,mod02_rs,mod03_pm,mod04_sched,mod05_vfs,mod06_memory,mod07_tty,mod08_mib,mod09_vm,mod10_pfs,mod11_mfs,mod12_init"
#+END_SRC

Linux 内核启动方式
#+BEGIN_SRC sh
  cd /data/os/x86_64/buildroot-2023.02.5/output/images

  qemu-system-x86_64 \
      -M pc \
      -nographic \
      -kernel bzImage \
      -drive file=rootfs.ext2,if=virtio,format=raw \
      -append "rootwait root=/dev/vda console=tty1 console=ttyS0" \
      -net nic,model=virtio -net user
#+END_SRC

** GDB 调试 XV6
qemu 通过 gdb server 来支持 gdb 调试，启动时需要添加下面选项来开启调试
1. -S 启动时不要立即执行 CPU 指令，等待 c 命令
2. -s 开启 gdb 监听端口 1234, 这样 gdb 可以使用下面命令来链接到 qemu
   #+BEGIN_EXAMPLE
     (gdb) target remote :1234
   #+END_EXAMPLE
3. -s 也可以是 ~-gdb tcp::1234~ 的简写，也可以制定其他端口

以 xv6-public 为例，通过 make qemu-nox-gdb 可以开启调试
#+BEGIN_SRC sh
  sed "s/localhost:1234/localhost:26000/" < .gdbinit.tmpl > .gdbinit
  qemu-system-i386 \
      -nographic -drive file=fs.img,index=1,media=disk,format=raw \
      -drive file=xv6.img,index=0,media=disk,format=raw -smp 2 -m 512 \
      -S -gdb tcp::26000
#+END_SRC

** 模拟器的优缺点
1. 优点
   - 方便快捷，无需重启电脑
   - 可以作为 gdb server 来调试
   - 提供了丰富的调试命令, info regs, info tlb
   - 支持多架构 x86, riscv, arm, mips 等
   - 开源免费
2. 缺点
   - 模拟器性能会有一些损耗

* 编写最小操作系统
** 中断，陷阱和系统调用
中断(Interrupt) 是指 CPU 停下当前的工作任务，去处理其他事情，处理完后回来继续执
行刚才的任务
- 中断是硬件实现的基础功能
- HelpPC Reference Library [[https://stanislavs.org/helppc/idx_interrupt.html][Interrupt Services]]
- Interrupts [[https://wiki.osdev.org/Interrupts][osdev]]

#+BEGIN_SRC asm
  int $0x80 # 中断号
  cli
  sti
#+END_SRC

BIOS 提供一下中断，[[https://stanislavs.org/helppc/idx_interrupt.html][link]]
| 功能码 | 说明                   |
|--------+------------------------|
|   0x13 | 读取磁盘数据           |
|   0x14 | 异步通信: 串口输出字符 |
|   0x16 | 读取键盘输入           |
|   0x1a | 时钟中断               |

陷阱(Trap)：是一种有意的，预先安排的异常事件
1. 一般是在编写程序时故意设下的陷阱指令，而后执行到陷阱指令后，CPU 将会调用特定
   程序进行相应的处理，处理结束后返回到陷阱指令的下一条指令
2. 如系统调用，程序调试功能等, 最常见的就是 Linux 系统调用的实现，使用中断指令

系统调用(System Call) 指操作系统提供给应用的一组 API 函数， Linux 系统调用见

查看 32 位操作系统系统调用号 NR_syscall 文件见
#+BEGIN_SRC sh :results output :exports both
  rg -n NR_write /usr/src/linux-headers-5.15.0-87-generic
#+END_SRC

#+RESULTS:
: /usr/src/linux-headers-5.15.0-87-generic/arch/x86/include/generated/uapi/asm/unistd_32.h:8:#define __NR_write 4
: /usr/src/linux-headers-5.15.0-87-generic/arch/x86/include/generated/uapi/asm/unistd_32.h:150:#define __NR_writev 146
: /usr/src/linux-headers-5.15.0-87-generic/arch/x86/include/generated/uapi/asm/unistd_64.h:5:#define __NR_write 1
: /usr/src/linux-headers-5.15.0-87-generic/arch/x86/include/generated/uapi/asm/unistd_64.h:24:#define __NR_writev 20
: /usr/src/linux-headers-5.15.0-87-generic/arch/x86/include/generated/uapi/asm/unistd_x32.h:5:#define __NR_write (__X32_SYSCALL_BIT + 1)
: /usr/src/linux-headers-5.15.0-87-generic/arch/x86/include/generated/uapi/asm/unistd_x32.h:321:#define __NR_writev (__X32_SYSCALL_BIT + 516)


[[file:lab/05-interrupt/greet.S]]

通过 strace 查看系统调用过程
#+BEGIN_SRC sh :results output :exports both
  strace ./lab/05-interrupt/greet.out 2>&1 1>/dev/null
#+END_SRC

#+RESULTS:
: execve("./lab/05-interrupt/greet.out", ["./lab/05-interrupt/greet.out"], 0x7ffcb604f8b0 /* 56 vars */) = 0
: [ Process PID=82486 runs in 32 bit mode. ]
: write(1, "Hello from ASM!\n", 16)       = 16
: exit(0)                                 = ?
: +++ exited with 0 +++

** 系统引导及分段
#+BEGIN_SRC sh :results output :exports both
  objdump -d ./lab/05-interrupt/greet2.run | grep section
#+END_SRC

#+RESULTS:
: Disassembly of section .init:
: Disassembly of section .plt:
: Disassembly of section .plt.got:
: Disassembly of section .text:
: Disassembly of section .fini:

在 gas 汇编中对段的描述是 section, 例如
#+BEGIN_SRC asm
  .section .text  # 代码段, 可以简写 .text
  .section .data  # 数据段, 可以简写 .data
#+END_SRC

AT&T 寻址方式编写格式
#+BEGIN_QUOTE
  section:disp(base, index, scale)
#+END_QUOTE

#+BEGIN_SRC asm
  %es:msg # 寻址 es 段的 msg
#+END_SRC

操作系统在对地址空间访问是通过分段实现 (segment)
1. 段使用物理上连续的一块空间
2. x86 系列分段的历史原因
   - 8086 是 16 位地址线
   - 当 CPU 升级到 20 位地址线是会出现问题
   - 为了兼容, 280 芯片启用来段寄存器 cs, ds, ss, es 寄存器
   - 380 芯片又添加了段寄存器 fs, gs
   - 最终导致了实模式下段寻址模式

#+BEGIN_EXAMPLE
  真实地址 = 段地址 << 4 + address
              ^             ^
              |             |
        存储在段寄存器中   偏移
#+END_EXAMPLE

** 裸金属启动
回顾 BIOS 启动流程
- 启动地址 0x7c00
- 校验码   0x55aa => 0b01010101 0b10101010

#+BEGIN_SRC sh :results output
  gdb -q -ex 'p/t 0x55aa'
#+END_SRC

#+RESULTS:
: $1 = 101010110101010
: (gdb) quit

#+BEGIN_SRC sh :results output :exports both
  hexdump -n 512 ./lab/06-barebone/fda.img
#+END_SRC

#+RESULTS:
: 0000000 01b8 bb00 0002 03b9 ba00 0004 feeb 0000
: 0000010 0000 0000 0000 0000 0000 0000 0000 0000
: *
: 00001f0 0000 0000 0000 0000 0000 0000 0000 aa55
: 0000200

[[file:lab/06-barebone/boot.S]]


扩展: nasm 汇编器
[[file:lab/07-nasm-boot/boot.s]]
#+BEGIN_EXAMPLE
  (gdb) show disassembly-flavor intel
  att
  (gdb) set disassembly-flavor intel
#+END_EXAMPLE
