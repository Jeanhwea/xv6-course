#+TITLE: x86 体系结构及系统启动
#+AUTHOR: Jinghui Hu
#+EMAIL: hujinghui@buaa.edu.cn
#+DATE: <2023-10-23 Mon 13:26:59>
#+STARTUP: overview num indent

* x86 体系结构
** 寄存器及编译流程
| 分类         | 英文全称            | 16 位 | 32 位 | 64 位 |
|--------------+---------------------+-------+-------+-------|
| 通用寄存器   | Accumulator         | ax    | eax   | rax   |
| 通用寄存器   | Base                | bx    | ebx   | rbx   |
| 通用寄存器   | Counter             | cx    | ecx   | rcx   |
| 通用寄存器   | Data                | dx    | edx   | rdx   |
| 指针寄存器   | Stack Pointer       | sp    | esp   | rsp   |
| 指针寄存器   | Base Pointer        | bp    | ebp   | rbp   |
| 变地址寄存器 | Source Index        | si    | esi   | rsi   |
| 变地址寄存器 | Destination Index   | di    | edi   | rdi   |
| 控制寄存器   | Instruction Pointer | ip    | eip   | rip   |
| 控制寄存器   | Flag                | flag  | eflag | eflag |
| 段寄存器     | Code Segment        | cs    | cs    | cs    |
| 段寄存器     | Data Segment        | ds    | ds    | ds    |
| 段寄存器     | Stack Segment       | ss    | ss    | ss    |
| 段寄存器     | Extra Segment       | es    | es    | es    |

[[file:lab/01-register/main.S]]

操作示例
#+BEGIN_EXAMPLE
  info reg
  info reg eax
  p $esp

  layout asm
  layout reg
#+END_EXAMPLE

ubuntu 分清 32 位和 64 位, 如果是 64 为系统需要安装 32 为支持库
#+BEGIN_SRC sh
  apt install gcc-multilib
#+END_SRC

** 栈操作 push/pop
1. esp 指向栈的顶端
2. ebp 指向栈的基地址
3. push 操作时, esp = esp - 4, ebp 不变 (32b)
4. pop 操作时,  esp = esp + 4, ebp 不变

#+BEGIN_EXAMPLE
  origin:
     addr      data
     0x0008 |   1 |
     0x0007 |   0 | <- ebp  <-esp
     0x0006 |   0 |
     0x0005 |   2 |
     0x0004 |   2 |
     0x0003 |   2 |

  push: 操作后
     addr     data
     0x0008 |   1 |
     0x0007 |   0 | <- ebp
     0x0006 |   0 |
     0x0005 |   2 |
     0x0004 |   2 |
     0x0003 |   2 |        <-esp

  pop: 操作后
     addr     data
     0x0008 |   1 |
     0x0007 |   0 | <- ebp <-esp
     0x0006 |   0 |
     0x0005 |   2 |
     0x0004 |   2 |
     0x0003 |   2 |
#+END_EXAMPLE

[[file:lab/02-stack/main.S]]

.gdbinit 定义 hook, 设置 watch point
#+BEGIN_EXAMPLE
  define hook-stepi
    if $ebp > 0
      # printf "ebp=%p, esp=%p\n", $ebp, $esp
      x/4x $ebp-16
      x/i $eip
    end
  end

  starti
  watch $ebp
  watch $esp
#+END_EXAMPLE

** 分支跳转 jmp
通常汇编的跳转通过 ~cmp~, ~je~, ~jmp~ 等指令配合实现，例如
#+BEGIN_SRC asm
  jmp label
#+END_SRC

[[file:lab/03-control-flow/jump.S]]

** 函数调用 call/ret
函数调用也属于简单的跳转指令, 例如
- call 调用函数
- ret 函数返回

[[file:lab/03-control-flow/fcall.S]]

使用 gcc 编译的真实函数调用
#+BEGIN_SRC sh
  gcc -m32 -O0 adder.c -o adder.out
  objdump -d adder.out > adder.asm
#+END_SRC

[[file:lab/03-control-flow/adder.c]]

#+BEGIN_SRC asm
  0000118d <add>:
      118d:	55                      push   %ebp
      118e:	89 e5                   mov    %esp,%ebp
      1190:	83 ec 10                sub    $0x10,%esp
      1193:	e8 49 00 00 00          call   11e1 <__x86.get_pc_thunk.ax>
      1198:	05 44 2e 00 00          add    $0x2e44,%eax
      119d:	8b 55 08                mov    0x8(%ebp),%edx
      11a0:	8b 45 0c                mov    0xc(%ebp),%eax
      11a3:	01 d0                   add    %edx,%eax
      11a5:	89 45 fc                mov    %eax,-0x4(%ebp)
      11a8:	8b 45 fc                mov    -0x4(%ebp),%eax
      11ab:	c9                      leave
      11ac:	c3                      ret

  000011ad <main>:
      11ad:	55                      push   %ebp
      11ae:	89 e5                   mov    %esp,%ebp
      11b0:	83 ec 10                sub    $0x10,%esp
      11b3:	e8 29 00 00 00          call   11e1 <__x86.get_pc_thunk.ax>
      11b8:	05 24 2e 00 00          add    $0x2e24,%eax
      11bd:	c7 45 f4 03 00 00 00    movl   $0x3,-0xc(%ebp)
      11c4:	c7 45 f8 04 00 00 00    movl   $0x4,-0x8(%ebp)
      11cb:	ff 75 f8                push   -0x8(%ebp)
      11ce:	ff 75 f4                push   -0xc(%ebp)
      11d1:	e8 b7 ff ff ff          call   118d <add>
      11d6:	83 c4 08                add    $0x8,%esp
      11d9:	89 45 fc                mov    %eax,-0x4(%ebp)
      11dc:	8b 45 fc                mov    -0x4(%ebp),%eax
      11df:	c9                      leave
      11e0:	c3                      ret
#+END_SRC

* QEMU 模拟器
** 什么是模拟器
1. [[https://www.qemu.org/][qemu]]
2. [[https://bochs.sourceforge.io/][bochs]]

操作系统：直接通过指令对硬件进行控制
#+BEGIN_EXAMPLE
  +============================================+
  ||  Operation System (操作系统): Linux, xv6 ||
  +============================================+
              |                    |
              |  Instruction(x86)  |
              v                    v
  +============================================+
  ||  Hardware(硬件): 硬盘，鼠标，显示器      ||
  +============================================+
#+END_EXAMPLE


模拟器：直接通过指令对硬件进行控制
#+BEGIN_EXAMPLE
  +============================================+
  || Host OS: Ubuntu                          ||
  ||                                          ||
  ||      +--------------------------------+  ||
  ||      | 调试操作系统: xv6-riscv        |  ||
  ||      +--------------------------------+  ||
  ||          |                     |         ||
  ||          |  Instruction(riscv) |         ||
  ||          V                     v         ||
  ||      +--------------------------------+  ||
  ||      | Simulator(模拟器): QEMU, Bochs |  ||
  ||      |    作为软件运行在宿主机器      |  ||
  ||      +--------------------------------+  ||
  ||              |                           ||
  ||              | 宿主操作系统指令(x86)     ||
  ||              |                           ||
  ||              V                           ||
  +============================================+
              |                    |
              |  Instruction(x86)  |
              v                    v
  +============================================+
  ||  Hardware(硬件): 硬盘，鼠标，显示器      ||
  +============================================+
#+END_EXAMPLE

** 操作系统启动过程
1. ~启动 BIOS~ Basic Input/Output System，基本输入输出系统。
   1) =供电初始化= 按下电源开关后，电源就开始给主板和其他设备供电，CPU 会把所有寄
      存器的值都设为默认值，即恢复初始状态。随后 CPU 会执行初始位置的指令，跳转到
      BIOS 启动代码位置，开始启动 BIOS。
   2) =POST 硬件自检= BIOS 首先进行 POST（Power On Self Test，硬件自检），检查计算
      机硬件是否满足运行的基本条件，并完成相应的初始化工作。如果发现了问题，主板会
      发出不同的蜂鸣声表示不同的问题。
   3) =搜索可引导的存储设备= BIOS 按照启动顺序开始搜索可引导的存储设备，找到后，会
      将存储设备中的引导扇区读入物理内存，并执行引导扇区中的程序，开始系统引导。
   4) BIOS 是按照顺序依次搜索可引导的存储设备的，这个顺序就叫启动顺序（Boot
      Sequence），可以在 BIOS 中进行查看和修改。
2. ~系统引导~
   1) =读取 MBR= 读取并执行硬盘的第一个扇区，即 MBR（Master Boot Record，主引导记
      录，大小为 512 字节）。其作用为告诉计算机到硬盘的哪一个位置去找操作系统。MBR
      的结构如下：
      + 第 1-446 字节：调用操作系统的机器码，可以被 CPU 直接执行
      + 第 447-510 字节：分区表（Partition Table），将硬盘分为了若干个分区
      + 第 511-512 字节：记录签名（0x55 和 0xAA），表示设备可以用于启动
   2) =查找活动分区= 搜索 MBR 中的分区表，找到唯一的活动分区（Active Partition），
      并将活动分区的第一个扇区中的引导扇区（称为 卷引导记录，Volume Boot Record，
      VBR）读入内存，就能找到操作系统在这个分区中的位置。然后，计算机就会开始加载
      操作系统了。
3. ~启动系统~ 由于一台计算机中可以安装多个操作系统，所以启动系统时也会有不同的情
   况。当有多个操作系统时，会运行启动管理器（Boot Loader），让用户选择启动操作系
   统； 当只有一个操作系统时，就会直接从激活分区中启动操作系统（当然也可以选择将
   控制权交 给启动管理器，boot loader 可以存在 MBR 中，也可以存在主分区的引导扇
   区中）。
4. ~初始化系统~ 操作系统启动后，控制权就从 boot loader 转交给了操作系统，之后，
   操作系统的内核首先被载入缓存，随后会运行初始化进程进行操作系统的初始化。

至此，整个计算机的启动过程就完成了。

** 普通启动
存储设备
1. 软盘 -fda
2. 硬盘 -hda
3. 光盘介质 -cdrom
#+BEGIN_SRC sh
  man qemu
#+END_SRC

启动 linux 0.11 系统
1. 指定软盘 Image
2. 指定硬盘 hdc-0.11.img
3. -boot a 表示从软盘启动,  man qemu ... /-boot
#+BEGIN_SRC sh
  qemu-system-i386 -boot a -fda Image -hda hdc-0.11.img
#+END_SRC

启动 xv6, 控制系统硬件参数
1. -smp CPU 数据
2. -m   内存大小
3. -nographic 表示不启动图形界面, 无图形界面的常用快捷键如下：
   + =ctrl-a x= 退出 qemu
   + =ctrl-a c= 切换串口
   + =ctrl-a h= 帮助
#+BEGIN_SRC sh
  qemu-system-i386 -smp 2 -m 512 -nographic -hda xv6.img -hdb fs.img
#+END_SRC

另外存储驱动也可以使用下面方法指定
#+BEGIN_SRC sh
  qemu-system-i386 -smp 2 -m 512 -nographic \
      -drive file=fs.img,index=1,media=disk,format=raw \
      -drive file=xv6.img,index=0,media=disk,format=raw
#+END_SRC

** initrd 启动
initrd 全称是 initial RAM disk ，它提供一种让核心可以简单使用 Ramdisk 的能力
1. 格式化一个 Ramdisk
2. 加载文件系统内容到 Ramdisk
3. 将 Ramdisk 作为根文件系统

MINIX 3 的 initrd 启动
#+BEGIN_SRC sh
  cd /data/os/minix/obj.i386/work
  qemu-system-i386 \
      --enable-kvm \
      -m 1G \
      -kernel kernel \
      -append "bootramdisk=1" \
      -initrd "mod01_ds,mod02_rs,mod03_pm,mod04_sched,mod05_vfs,mod06_memory,mod07_tty,mod08_mib,mod09_vm,mod10_pfs,mod11_mfs,mod12_init"
#+END_SRC

Linux 内核启动方式
#+BEGIN_SRC sh
  cd /data/os/x86_64/buildroot-2023.02.5/output/images

  qemu-system-x86_64 \
      -M pc \
      -nographic \
      -kernel bzImage \
      -drive file=rootfs.ext2,if=virtio,format=raw \
      -append "rootwait root=/dev/vda console=tty1 console=ttyS0" \
      -net nic,model=virtio -net user
#+END_SRC

** GDB 调试 XV6
qemu 通过 gdb server 来支持 gdb 调试，启动时需要添加下面选项来开启调试
1. -S 启动时不要立即执行 CPU 指令，等待 c 命令
2. -s 开启 gdb 监听端口 1234, 这样 gdb 可以使用下面命令来链接到 qemu
   #+BEGIN_EXAMPLE
     (gdb) target remote :1234
   #+END_EXAMPLE
3. -s 也可以是 ~-gdb tcp::1234~ 的简写，也可以制定其他端口

以 xv6-public 为例，通过 make qemu-nox-gdb 可以开启调试
#+BEGIN_SRC sh
  sed "s/localhost:1234/localhost:26000/" < .gdbinit.tmpl > .gdbinit
  qemu-system-i386 \
      -nographic -drive file=fs.img,index=1,media=disk,format=raw \
      -drive file=xv6.img,index=0,media=disk,format=raw -smp 2 -m 512 \
      -S -gdb tcp::26000
#+END_SRC

** 模拟器的优缺点
1. 优点
   - 方便快捷，无需重启电脑
   - 可以作为 gdb server 来调试
   - 提供了丰富的调试命令, info regs, info tlb
   - 支持多架构 x86, riscv, arm, mips 等
   - 开源免费
2. 缺点
   - 模拟器性能会有一些损耗

* 编写最小操作系统
** 中断，陷阱和系统调用
中断(Interrupt) 是指 CPU 停下当前的工作任务，去处理其他事情，处理完后回来继续执
行刚才的任务 [[https://stanislavs.org/helppc/idx_interrupt.html][Interrupt Services]] , 中断是硬件实现的基础功能
#+BEGIN_SRC asm
  int 0x80 # 中断号
#+END_SRC

BIOS 提供一下中断，[[https://stanislavs.org/helppc/idx_interrupt.html][link]]
| 功能码 | 说明                   |
|--------+------------------------|
|   0x13 | 读取磁盘数据           |
|   0x14 | 异步通信: 串口输出字符 |
|   0x16 | 读取键盘输入           |
|   0x1a | 时钟中断               |

陷阱(Trap)：是一种有意的，预先安排的异常事件
1. 一般是在编写程序时故意设下的陷阱指令，而后执行到陷阱指令后，CPU 将会调用特定
   程序进行相应的处理，处理结束后返回到陷阱指令的下一条指令
2. 如系统调用，程序调试功能等, 最常见的就是 Linux 系统调用的实现，使用中断指令

系统调用(System Call) 指操作系统提供给应用的一组 API 函数， Linux 系统调用见

查看 32 位操作系统系统调用号 NR_syscal 文件见
#+BEGIN_EXAMPLE
  /usr/src/linux-headers-5.15.0-87-generic » rg NR_write
  arch/x86/include/generated/uapi/asm/unistd_64.h
  5:#define __NR_write 1
  24:#define __NR_writev 20

  arch/x86/include/generated/uapi/asm/unistd_32.h
  8:#define __NR_write 4
  150:#define __NR_writev 146

  arch/x86/include/generated/uapi/asm/unistd_x32.h
  5:#define __NR_write (__X32_SYSCALL_BIT + 1)
  321:#define __NR_writev (__X32_SYSCALL_BIT + 516)
#+END_EXAMPLE

[[file:lab/05-interrupt/greet.S]]

通过 strace 查看系统调用过程
#+BEGIN_SRC sh :results output :exports both
  strace ./lab/05-interrupt/greet.out 2>&1 1>/dev/null
#+END_SRC

#+RESULTS:
: execve("./lab/05-interrupt/greet.out", ["./lab/05-interrupt/greet.out"], 0x7ffcb604f8b0 /* 56 vars */) = 0
: [ Process PID=82486 runs in 32 bit mode. ]
: write(1, "Hello from ASM!\n", 16)       = 16
: exit(0)                                 = ?
: +++ exited with 0 +++

** 系统引导及分段
#+BEGIN_SRC sh :results output :exports both
  objdump -d ./lab/05-interrupt/greet2.run
#+END_SRC

#+RESULTS:
#+begin_example

  ./lab/05-interrupt/greet2.run:     file format elf32-i386


  Disassembly of section .init:

  00001000 <_init>:
      1000:	f3 0f 1e fb             endbr32
      1004:	53                      push   %ebx
      1005:	83 ec 08                sub    $0x8,%esp
      1008:	e8 93 00 00 00          call   10a0 <__x86.get_pc_thunk.bx>
      100d:	81 c3 cb 2f 00 00       add    $0x2fcb,%ebx
      1013:	8b 83 1c 00 00 00       mov    0x1c(%ebx),%eax
      1019:	85 c0                   test   %eax,%eax
      101b:	74 02                   je     101f <_init+0x1f>
      101d:	ff d0                   call   *%eax
      101f:	83 c4 08                add    $0x8,%esp
      1022:	5b                      pop    %ebx
      1023:	c3                      ret

  Disassembly of section .plt:

  00001030 <__libc_start_main@plt-0x10>:
      1030:	ff b3 04 00 00 00       push   0x4(%ebx)
      1036:	ff a3 08 00 00 00       jmp    *0x8(%ebx)
      103c:	00 00                   add    %al,(%eax)
          ...

  00001040 <__libc_start_main@plt>:
      1040:	ff a3 0c 00 00 00       jmp    *0xc(%ebx)
      1046:	68 00 00 00 00          push   $0x0
      104b:	e9 e0 ff ff ff          jmp    1030 <_init+0x30>

  00001050 <write@plt>:
      1050:	ff a3 10 00 00 00       jmp    *0x10(%ebx)
      1056:	68 08 00 00 00          push   $0x8
      105b:	e9 d0 ff ff ff          jmp    1030 <_init+0x30>

  Disassembly of section .plt.got:

  00001060 <__cxa_finalize@plt>:
      1060:	ff a3 18 00 00 00       jmp    *0x18(%ebx)
      1066:	66 90                   xchg   %ax,%ax

  Disassembly of section .text:

  00001070 <_start>:
      1070:	f3 0f 1e fb             endbr32
      1074:	31 ed                   xor    %ebp,%ebp
      1076:	5e                      pop    %esi
      1077:	89 e1                   mov    %esp,%ecx
      1079:	83 e4 f0                and    $0xfffffff0,%esp
      107c:	50                      push   %eax
      107d:	54                      push   %esp
      107e:	52                      push   %edx
      107f:	e8 18 00 00 00          call   109c <_start+0x2c>
      1084:	81 c3 54 2f 00 00       add    $0x2f54,%ebx
      108a:	6a 00                   push   $0x0
      108c:	6a 00                   push   $0x0
      108e:	51                      push   %ecx
      108f:	56                      push   %esi
      1090:	ff b3 20 00 00 00       push   0x20(%ebx)
      1096:	e8 a5 ff ff ff          call   1040 <__libc_start_main@plt>
      109b:	f4                      hlt
      109c:	8b 1c 24                mov    (%esp),%ebx
      109f:	c3                      ret

  000010a0 <__x86.get_pc_thunk.bx>:
      10a0:	8b 1c 24                mov    (%esp),%ebx
      10a3:	c3                      ret
      10a4:	66 90                   xchg   %ax,%ax
      10a6:	66 90                   xchg   %ax,%ax
      10a8:	66 90                   xchg   %ax,%ax
      10aa:	66 90                   xchg   %ax,%ax
      10ac:	66 90                   xchg   %ax,%ax
      10ae:	66 90                   xchg   %ax,%ax

  000010b0 <deregister_tm_clones>:
      10b0:	e8 e4 00 00 00          call   1199 <__x86.get_pc_thunk.dx>
      10b5:	81 c2 23 2f 00 00       add    $0x2f23,%edx
      10bb:	8d 8a 40 00 00 00       lea    0x40(%edx),%ecx
      10c1:	8d 82 40 00 00 00       lea    0x40(%edx),%eax
      10c7:	39 c8                   cmp    %ecx,%eax
      10c9:	74 1d                   je     10e8 <deregister_tm_clones+0x38>
      10cb:	8b 82 14 00 00 00       mov    0x14(%edx),%eax
      10d1:	85 c0                   test   %eax,%eax
      10d3:	74 13                   je     10e8 <deregister_tm_clones+0x38>
      10d5:	55                      push   %ebp
      10d6:	89 e5                   mov    %esp,%ebp
      10d8:	83 ec 14                sub    $0x14,%esp
      10db:	51                      push   %ecx
      10dc:	ff d0                   call   *%eax
      10de:	83 c4 10                add    $0x10,%esp
      10e1:	c9                      leave
      10e2:	c3                      ret
      10e3:	8d 74 26 00             lea    0x0(%esi,%eiz,1),%esi
      10e7:	90                      nop
      10e8:	c3                      ret
      10e9:	8d b4 26 00 00 00 00    lea    0x0(%esi,%eiz,1),%esi

  000010f0 <register_tm_clones>:
      10f0:	e8 a4 00 00 00          call   1199 <__x86.get_pc_thunk.dx>
      10f5:	81 c2 e3 2e 00 00       add    $0x2ee3,%edx
      10fb:	55                      push   %ebp
      10fc:	89 e5                   mov    %esp,%ebp
      10fe:	53                      push   %ebx
      10ff:	8d 8a 40 00 00 00       lea    0x40(%edx),%ecx
      1105:	8d 82 40 00 00 00       lea    0x40(%edx),%eax
      110b:	83 ec 04                sub    $0x4,%esp
      110e:	29 c8                   sub    %ecx,%eax
      1110:	89 c3                   mov    %eax,%ebx
      1112:	c1 e8 1f                shr    $0x1f,%eax
      1115:	c1 fb 02                sar    $0x2,%ebx
      1118:	01 d8                   add    %ebx,%eax
      111a:	d1 f8                   sar    %eax
      111c:	74 14                   je     1132 <register_tm_clones+0x42>
      111e:	8b 92 24 00 00 00       mov    0x24(%edx),%edx
      1124:	85 d2                   test   %edx,%edx
      1126:	74 0a                   je     1132 <register_tm_clones+0x42>
      1128:	83 ec 08                sub    $0x8,%esp
      112b:	50                      push   %eax
      112c:	51                      push   %ecx
      112d:	ff d2                   call   *%edx
      112f:	83 c4 10                add    $0x10,%esp
      1132:	8b 5d fc                mov    -0x4(%ebp),%ebx
      1135:	c9                      leave
      1136:	c3                      ret
      1137:	8d b4 26 00 00 00 00    lea    0x0(%esi,%eiz,1),%esi
      113e:	66 90                   xchg   %ax,%ax

  00001140 <__do_global_dtors_aux>:
      1140:	f3 0f 1e fb             endbr32
      1144:	55                      push   %ebp
      1145:	89 e5                   mov    %esp,%ebp
      1147:	53                      push   %ebx
      1148:	e8 53 ff ff ff          call   10a0 <__x86.get_pc_thunk.bx>
      114d:	81 c3 8b 2e 00 00       add    $0x2e8b,%ebx
      1153:	83 ec 04                sub    $0x4,%esp
      1156:	80 bb 3e 00 00 00 00    cmpb   $0x0,0x3e(%ebx)
      115d:	75 27                   jne    1186 <__do_global_dtors_aux+0x46>
      115f:	8b 83 18 00 00 00       mov    0x18(%ebx),%eax
      1165:	85 c0                   test   %eax,%eax
      1167:	74 11                   je     117a <__do_global_dtors_aux+0x3a>
      1169:	83 ec 0c                sub    $0xc,%esp
      116c:	ff b3 2c 00 00 00       push   0x2c(%ebx)
      1172:	e8 e9 fe ff ff          call   1060 <__cxa_finalize@plt>
      1177:	83 c4 10                add    $0x10,%esp
      117a:	e8 31 ff ff ff          call   10b0 <deregister_tm_clones>
      117f:	c6 83 3e 00 00 00 01    movb   $0x1,0x3e(%ebx)
      1186:	8b 5d fc                mov    -0x4(%ebp),%ebx
      1189:	c9                      leave
      118a:	c3                      ret
      118b:	8d 74 26 00             lea    0x0(%esi,%eiz,1),%esi
      118f:	90                      nop

  00001190 <frame_dummy>:
      1190:	f3 0f 1e fb             endbr32
      1194:	e9 57 ff ff ff          jmp    10f0 <register_tm_clones>

  00001199 <__x86.get_pc_thunk.dx>:
      1199:	8b 14 24                mov    (%esp),%edx
      119c:	c3                      ret

  0000119d <main>:
      119d:	8d 4c 24 04             lea    0x4(%esp),%ecx
      11a1:	83 e4 f0                and    $0xfffffff0,%esp
      11a4:	ff 71 fc                push   -0x4(%ecx)
      11a7:	55                      push   %ebp
      11a8:	89 e5                   mov    %esp,%ebp
      11aa:	53                      push   %ebx
      11ab:	51                      push   %ecx
      11ac:	e8 2c 00 00 00          call   11dd <__x86.get_pc_thunk.ax>
      11b1:	05 27 2e 00 00          add    $0x2e27,%eax
      11b6:	83 ec 04                sub    $0x4,%esp
      11b9:	6a 0d                   push   $0xd
      11bb:	8d 90 30 00 00 00       lea    0x30(%eax),%edx
      11c1:	52                      push   %edx
      11c2:	6a 01                   push   $0x1
      11c4:	89 c3                   mov    %eax,%ebx
      11c6:	e8 85 fe ff ff          call   1050 <write@plt>
      11cb:	83 c4 10                add    $0x10,%esp
      11ce:	b8 00 00 00 00          mov    $0x0,%eax
      11d3:	8d 65 f8                lea    -0x8(%ebp),%esp
      11d6:	59                      pop    %ecx
      11d7:	5b                      pop    %ebx
      11d8:	5d                      pop    %ebp
      11d9:	8d 61 fc                lea    -0x4(%ecx),%esp
      11dc:	c3                      ret

  000011dd <__x86.get_pc_thunk.ax>:
      11dd:	8b 04 24                mov    (%esp),%eax
      11e0:	c3                      ret

  Disassembly of section .fini:

  000011e4 <_fini>:
      11e4:	f3 0f 1e fb             endbr32
      11e8:	53                      push   %ebx
      11e9:	83 ec 08                sub    $0x8,%esp
      11ec:	e8 af fe ff ff          call   10a0 <__x86.get_pc_thunk.bx>
      11f1:	81 c3 e7 2d 00 00       add    $0x2de7,%ebx
      11f7:	83 c4 08                add    $0x8,%esp
      11fa:	5b                      pop    %ebx
      11fb:	c3                      ret
#+end_example


操作系统在对地址空间访问是通过分段实现 (segment)
1. 段使用物理上连续的一块空间
2. 分段的历史
   - 8086 是 16 位地址线
   - 当 cpu 升级到 20 位地址线是会出现问题,
   - 为了兼容, 280 芯片启用来段寄存器 cs, ds, ss, es 寄存器
   - 380 芯片又添加了段寄存器 fs, gs
   - 最终导致了实模式下段寻址模式
   #+BEGIN_EXAMPLE
     真实地址 = 段地址 << 4 + address
                 ^             ^
                 |             |
           存储在段寄存器中   偏移
   #+END_EXAMPLE

在 gas 汇编中对段的描述是 section, 例如
#+BEGIN_SRC asm
  .section .text  # 代码段, 可以简写 .text
  .section .data  # 数据段, 可以简写 .data
#+END_SRC

AT&T 寻址方式
#+BEGIN_QUOTE
  section:disp(base, index, scale)
#+END_QUOTE

#+BEGIN_SRC asm
  %es:msg # 寻址 es 段的 msg
#+END_SRC

** GDT
1. GDT 主要保护以下信息, 总共 64 位, [[https://files.osdev.org/mirrors/geezer/os/pm.htm][link]]
   - base  = low(16) + middle(8) + high(8)
   - limit = low(16) + high(4)
   - flags = (12)
2. GDT 的第一项必须全是 ~0x00~
3. GDT 加载通过 ~lgdt~ 指令

下面是一个初始化的 gdt 内存定义，这里先将代码段和数据段合并在一起
#+BEGIN_SRC asm
  gdt_start: ; don't remove the labels, they're needed to compute sizes and jumps
      ; the GDT starts with a null 8-byte
      dd 0x0 ; 4 byte
      dd 0x0 ; 4 byte

  ; GDT for code segment. base = 0x00000000, length = 0xfffff
  gdt_code:
      dw 0xffff    ; segment length, bits 0-15                    | limit_low(16)
      dw 0x0       ; segment base, bits 0-15                      | base_low(16)
      db 0x0       ; segment base, bits 16-23                     | base_middle(8)
      db 10011010b ; flags (8 bits)                               | flags1(8)
      db 11001111b ; flags (4 bits) + segment length, bits 16-19  | limit_high(4), flags2(4)
      db 0x0       ; segment base, bits 24-31                     | base_high(8)

  gdt_data:
      dw 0xffff
      dw 0x0
      db 0x0
      db 10010010b
      db 11001111b
      db 0x0

  gdt_end:

  ; GDT descriptor, via lgdt [gdt_descriptor]
  gdt_descriptor:
      dw gdt_end - gdt_start - 1 ; size (16 bit), always one less of its true size
      dd gdt_start               ; address (32 bit)

  ; define some constants for later use
  CODE_SEG equ gdt_code - gdt_start
  DATA_SEG equ gdt_data - gdt_start
#+END_SRC

** 实模式到保护模式切换
1. 关闭中断
2. 加载 gdt
3. 设置控制寄存器 ~cr0~
4. 通过远程调整来 flush 流水线
5. 更新所以的段寄存器
6. 更新系统栈
7. 跳转到 32 位指令出执行

#+BEGIN_SRC asm
  ;;; real mode
  [bits 16]
  switch_to_pm:
      cli                         ; 1. disable interrupts
      lgdt [gdt_descriptor]       ; 2. load the GDT descriptor
      mov eax, cr0
      or eax, 0x1                 ; 3. set 32-bit mode bit in cr0
      mov cr0, eax
      jmp CODE_SEG:init_pm        ; 4. far jump by using a different segment

  ;;; protected mode is enabled
  [bits 32]
  init_pm:
      mov ax, DATA_SEG            ; 5. update the segment registers
      mov ds, ax
      mov ss, ax
      mov es, ax
      mov fs, ax
      mov gs, ax

      mov ebp, 0x90000            ; 6. update the stack right at the top of the free space
      mov esp, ebp

      call BEGIN_PM               ; 7. Call a well-known label with useful code
#+END_SRC
